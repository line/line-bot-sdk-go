/**
 * Channel Access Token API
 * This document describes Channel Access Token API.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

//go:generate python3 ../../generate-code.py

package channel_access_token

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"path"

	"github.com/line/line-bot-sdk-go/v7/linebot"
)

type ChannelAccessTokenAPI struct {
	httpClient   *http.Client
	endpoint     *url.URL
	channelToken string
	ctx          context.Context
}

// ChannelAccessTokenAPIOption type
type ChannelAccessTokenAPIOption func(*ChannelAccessTokenAPI) error

// New returns a new bot client instance.
func NewChannelAccessTokenAPI(channelToken string, options ...ChannelAccessTokenAPIOption) (*ChannelAccessTokenAPI, error) {
	if channelToken == "" {
		return nil, errors.New("missing channel access token")
	}

	c := &ChannelAccessTokenAPI{
		channelToken: channelToken,
		httpClient:   http.DefaultClient,
	}

	u, err := url.ParseRequestURI("https://api.line.me")
	if err != nil {
		return nil, err
	}
	c.endpoint = u

	for _, option := range options {
		err := option(c)
		if err != nil {
			return nil, err
		}
	}
	return c, nil
}

// WithContext method
func (call *ChannelAccessTokenAPI) WithContext(ctx context.Context) *ChannelAccessTokenAPI {
	call.ctx = ctx
	return call
}

func (client *ChannelAccessTokenAPI) Do(req *http.Request) (*http.Response, error) {
	if client.channelToken != "" {
		req.Header.Set("Authorization", "Bearer "+client.channelToken)
	}
	req.Header.Set("User-Agent", "LINE-BotSDK-Go/"+linebot.GetVersion())
	if client.ctx != nil {
		req = req.WithContext(client.ctx)
	}
	return client.httpClient.Do(req)
}

func (client *ChannelAccessTokenAPI) Url(endpointPath string) string {
	u := client.endpoint
	u.Path = path.Join(u.Path, endpointPath)
	return u.String()
}

// WithHTTPClient function
func WithHTTPClient(c *http.Client) ChannelAccessTokenAPIOption {
	return func(client *ChannelAccessTokenAPI) error {
		client.httpClient = c
		return nil
	}
}

// WithEndpointClient function
func WithEndpoint(endpoint string) ChannelAccessTokenAPIOption {
	return func(client *ChannelAccessTokenAPI) error {
		u, err := url.ParseRequestURI(endpoint)
		if err != nil {
			return err
		}
		client.endpoint = u
		return nil
	}
}

// GetsAllValidChannelAccessTokenKeyIds
//
// Gets all valid channel access token key IDs.
// Parameters:
//        clientAssertionType             `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`
//        clientAssertion             A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.

// https://developers.line.biz/en/reference/messaging-api/#get-all-valid-channel-access-token-key-ids-v2-1
func (client *ChannelAccessTokenAPI) GetsAllValidChannelAccessTokenKeyIds(

	clientAssertionType string,

	clientAssertion string,

) (*ChannelAccessTokenKeyIdsResponse, error) {
	path := "/oauth2/v2.1/tokens/kid"

	log.Printf("Sending request: method=Get path=%s\n", path)
	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, err
	}

	var query url.Values
	query = url.Values{"clientAssertionType": []string{string(clientAssertionType)}}
	query = url.Values{"clientAssertion": []string{string(clientAssertion)}}

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return nil, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		return nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := ChannelAccessTokenKeyIdsResponse{}
	if err := decoder.Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return &result, nil

}

// IssueChannelToken
//
// Issue short-lived channel access token
// Parameters:
//        grantType             `client_credentials`
//        clientId             Channel ID.
//        clientSecret             Channel secret.

// https://developers.line.biz/en/reference/messaging-api/#issue-shortlived-channel-access-token
func (client *ChannelAccessTokenAPI) IssueChannelToken(

	grantType string,

	clientId string,

	clientSecret string,

) (*IssueShortLivedChannelAccessTokenResponse, error) {
	path := "/v2/oauth/accessToken"

	vs := url.Values{
		"grant_type":    []string{string(grantType)},
		"client_id":     []string{string(clientId)},
		"client_secret": []string{string(clientSecret)},
	}
	buf := vs.Encode()
	body := bytes.NewBufferString(buf)

	log.Printf("Sending request: method=Post path=%s body=%s\n", path, buf)
	req, err := http.NewRequest(http.MethodPost, client.Url(path), body)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return nil, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		return nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := IssueShortLivedChannelAccessTokenResponse{}
	if err := decoder.Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return &result, nil

}

// IssueChannelTokenByJWT
//
// Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
// Parameters:
//        grantType             client_credentials
//        clientAssertionType             urn:ietf:params:oauth:client-assertion-type:jwt-bearer
//        clientAssertion             A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.

// https://developers.line.biz/en/reference/messaging-api/#issue-channel-access-token-v2-1
func (client *ChannelAccessTokenAPI) IssueChannelTokenByJWT(

	grantType string,

	clientAssertionType string,

	clientAssertion string,

) (*IssueChannelAccessTokenResponse, error) {
	path := "/oauth2/v2.1/token"

	vs := url.Values{
		"grant_type":            []string{string(grantType)},
		"client_assertion_type": []string{string(clientAssertionType)},
		"client_assertion":      []string{string(clientAssertion)},
	}
	buf := vs.Encode()
	body := bytes.NewBufferString(buf)

	log.Printf("Sending request: method=Post path=%s body=%s\n", path, buf)
	req, err := http.NewRequest(http.MethodPost, client.Url(path), body)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return nil, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		return nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := IssueChannelAccessTokenResponse{}
	if err := decoder.Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return &result, nil

}

// IssueStatelessChannelToken
//
// Issues a new stateless channel access token, which doesn't have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires.
// Parameters:
//        grantType             `client_credentials`
//        clientAssertionType             URL-encoded value of `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`
//        clientAssertion             A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.
//        clientId             Channel ID.
//        clientSecret             Channel secret.

// https://developers.line.biz/en/reference/messaging-api/#issue-stateless-channel-access-token
func (client *ChannelAccessTokenAPI) IssueStatelessChannelToken(

	grantType string,

	clientAssertionType string,

	clientAssertion string,

	clientId string,

	clientSecret string,

) (*IssueStatelessChannelAccessTokenResponse, error) {
	path := "/oauth2/v3/token"

	vs := url.Values{
		"grant_type":            []string{string(grantType)},
		"client_assertion_type": []string{string(clientAssertionType)},
		"client_assertion":      []string{string(clientAssertion)},
		"client_id":             []string{string(clientId)},
		"client_secret":         []string{string(clientSecret)},
	}
	buf := vs.Encode()
	body := bytes.NewBufferString(buf)

	log.Printf("Sending request: method=Post path=%s body=%s\n", path, buf)
	req, err := http.NewRequest(http.MethodPost, client.Url(path), body)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return nil, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		return nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := IssueStatelessChannelAccessTokenResponse{}
	if err := decoder.Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return &result, nil

}

// RevokeChannelToken
//
// Revoke short-lived or long-lived channel access token
// Parameters:
//        accessToken             Channel access token

// https://developers.line.biz/en/reference/messaging-api/#revoke-longlived-or-shortlived-channel-access-token
func (client *ChannelAccessTokenAPI) RevokeChannelToken(

	accessToken string,

) (struct{}, error) {
	path := "/v2/oauth/revoke"

	vs := url.Values{
		"access_token": []string{string(accessToken)},
	}
	buf := vs.Encode()
	body := bytes.NewBufferString(buf)

	log.Printf("Sending request: method=Post path=%s body=%s\n", path, buf)
	req, err := http.NewRequest(http.MethodPost, client.Url(path), body)
	if err != nil {
		return struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		return struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	defer res.Body.Close()

	return struct{}{}, nil

}

// RevokeChannelTokenByJWT
//
// Revoke channel access token v2.1
// Parameters:
//        clientId             Channel ID
//        clientSecret             Channel Secret
//        accessToken             Channel access token

// https://developers.line.biz/en/reference/messaging-api/#revoke-channel-access-token-v2-1
func (client *ChannelAccessTokenAPI) RevokeChannelTokenByJWT(

	clientId string,

	clientSecret string,

	accessToken string,

) (struct{}, error) {
	path := "/oauth2/v2.1/revoke"

	vs := url.Values{
		"client_id":     []string{string(clientId)},
		"client_secret": []string{string(clientSecret)},
		"access_token":  []string{string(accessToken)},
	}
	buf := vs.Encode()
	body := bytes.NewBufferString(buf)

	log.Printf("Sending request: method=Post path=%s body=%s\n", path, buf)
	req, err := http.NewRequest(http.MethodPost, client.Url(path), body)
	if err != nil {
		return struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		return struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	defer res.Body.Close()

	return struct{}{}, nil

}

// VerifyChannelToken
//
// Verify the validity of short-lived and long-lived channel access tokens
// Parameters:
//        accessToken             A short-lived or long-lived channel access token.

// https://developers.line.biz/en/reference/messaging-api/#verfiy-channel-access-token
func (client *ChannelAccessTokenAPI) VerifyChannelToken(

	accessToken string,

) (*VerifyChannelAccessTokenResponse, error) {
	path := "/v2/oauth/verify"

	vs := url.Values{
		"access_token": []string{string(accessToken)},
	}
	buf := vs.Encode()
	body := bytes.NewBufferString(buf)

	log.Printf("Sending request: method=Post path=%s body=%s\n", path, buf)
	req, err := http.NewRequest(http.MethodPost, client.Url(path), body)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return nil, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		return nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := VerifyChannelAccessTokenResponse{}
	if err := decoder.Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return &result, nil

}

// VerifyChannelTokenByJWT
//
// You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
// Parameters:
//        accessToken             Channel access token with a user-specified expiration (Channel Access Token v2.1).

// https://developers.line.biz/en/reference/messaging-api/#verfiy-channel-access-token-v2-1
func (client *ChannelAccessTokenAPI) VerifyChannelTokenByJWT(

	accessToken string,

) (*VerifyChannelAccessTokenResponse, error) {
	path := "/oauth2/v2.1/verify"

	log.Printf("Sending request: method=Get path=%s\n", path)
	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, err
	}

	var query url.Values
	query = url.Values{"accessToken": []string{string(accessToken)}}

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return nil, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		return nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := VerifyChannelAccessTokenResponse{}
	if err := decoder.Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return &result, nil

}
