/**
 * LINE Messaging API
 * This document describes LINE Messaging API.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

//go:generate python3 ../../generate-code.py

package manage_audience

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"path"
	"strconv"
	"strings"

	"github.com/line/line-bot-sdk-go/v7/linebot"
)

type ManageAudienceAPI struct {
	httpClient   *http.Client
	endpoint     *url.URL
	channelToken string
	ctx          context.Context
}

// ManageAudienceAPIOption type
type ManageAudienceAPIOption func(*ManageAudienceAPI) error

// New returns a new bot client instance.
func NewManageAudienceAPI(channelToken string, options ...ManageAudienceAPIOption) (*ManageAudienceAPI, error) {
	if channelToken == "" {
		return nil, errors.New("missing channel access token")
	}

	c := &ManageAudienceAPI{
		channelToken: channelToken,
		httpClient:   http.DefaultClient,
	}

	u, err := url.ParseRequestURI("https://api.line.me")
	if err != nil {
		return nil, err
	}
	c.endpoint = u

	for _, option := range options {
		err := option(c)
		if err != nil {
			return nil, err
		}
	}
	return c, nil
}

// WithContext method
func (call *ManageAudienceAPI) WithContext(ctx context.Context) *ManageAudienceAPI {
	call.ctx = ctx
	return call
}

func (client *ManageAudienceAPI) Do(req *http.Request) (*http.Response, error) {
	if client.channelToken != "" {
		req.Header.Set("Authorization", "Bearer "+client.channelToken)
	}
	req.Header.Set("User-Agent", "LINE-BotSDK-Go/"+linebot.GetVersion())
	if client.ctx != nil {
		req = req.WithContext(client.ctx)
	}
	return client.httpClient.Do(req)
}

func (client *ManageAudienceAPI) Url(endpointPath string) string {
	u := client.endpoint
	u.Path = path.Join(u.Path, endpointPath)
	return u.String()
}

// WithHTTPClient function
func WithHTTPClient(c *http.Client) ManageAudienceAPIOption {
	return func(client *ManageAudienceAPI) error {
		client.httpClient = c
		return nil
	}
}

// WithEndpointClient function
func WithEndpoint(endpoint string) ManageAudienceAPIOption {
	return func(client *ManageAudienceAPI) error {
		u, err := url.ParseRequestURI(endpoint)
		if err != nil {
			return err
		}
		client.endpoint = u
		return nil
	}
}

// ActivateAudienceGroup
//
// Activate audience
// Parameters:
//        audienceGroupId             The audience ID.

// https://developers.line.biz/en/reference/messaging-api/#activate-audience-group
func (client *ManageAudienceAPI) ActivateAudienceGroup(

	audienceGroupId int64,

) (struct{}, error) {
	_, body, error := client.ActivateAudienceGroupWithHttpInfo(

		audienceGroupId,
	)
	return body, error
}

// ActivateAudienceGroup
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Activate audience
// Parameters:
//        audienceGroupId             The audience ID.

// https://developers.line.biz/en/reference/messaging-api/#activate-audience-group
func (client *ManageAudienceAPI) ActivateAudienceGroupWithHttpInfo(

	audienceGroupId int64,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/audienceGroup/{audienceGroupId}/activate"

	path = strings.Replace(path, "{audienceGroupId}", strconv.FormatInt(audienceGroupId, 10), -1)

	log.Printf("Sending request: method=Put path=%s\n", path)
	req, err := http.NewRequest(http.MethodPut, client.Url(path), nil)
	if err != nil {
		return nil, struct{}{}, err
	}

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// AddAudienceToAudienceGroup
//
// Add user IDs or Identifiers for Advertisers (IFAs) to an audience for uploading user IDs (by JSON)
// Parameters:
//        addAudienceToAudienceGroupRequest

// https://developers.line.biz/en/reference/messaging-api/#update-upload-audience-group
func (client *ManageAudienceAPI) AddAudienceToAudienceGroup(

	addAudienceToAudienceGroupRequest *AddAudienceToAudienceGroupRequest,

) (struct{}, error) {
	_, body, error := client.AddAudienceToAudienceGroupWithHttpInfo(

		addAudienceToAudienceGroupRequest,
	)
	return body, error
}

// AddAudienceToAudienceGroup
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Add user IDs or Identifiers for Advertisers (IFAs) to an audience for uploading user IDs (by JSON)
// Parameters:
//        addAudienceToAudienceGroupRequest

// https://developers.line.biz/en/reference/messaging-api/#update-upload-audience-group
func (client *ManageAudienceAPI) AddAudienceToAudienceGroupWithHttpInfo(

	addAudienceToAudienceGroupRequest *AddAudienceToAudienceGroupRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/audienceGroup/upload"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(addAudienceToAudienceGroupRequest); err != nil {
		return nil, struct{}{}, err
	}
	log.Printf("Sending request: method=Put path=%s body=%s\n", path, buf.String())
	req, err := http.NewRequest(http.MethodPut, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// CreateAudienceGroup
//
// Create audience for uploading user IDs (by JSON)
// Parameters:
//        createAudienceGroupRequest

// https://developers.line.biz/en/reference/messaging-api/#create-upload-audience-group
func (client *ManageAudienceAPI) CreateAudienceGroup(

	createAudienceGroupRequest *CreateAudienceGroupRequest,

) (*CreateAudienceGroupResponse, error) {
	_, body, error := client.CreateAudienceGroupWithHttpInfo(

		createAudienceGroupRequest,
	)
	return body, error
}

// CreateAudienceGroup
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Create audience for uploading user IDs (by JSON)
// Parameters:
//        createAudienceGroupRequest

// https://developers.line.biz/en/reference/messaging-api/#create-upload-audience-group
func (client *ManageAudienceAPI) CreateAudienceGroupWithHttpInfo(

	createAudienceGroupRequest *CreateAudienceGroupRequest,

) (*http.Response, *CreateAudienceGroupResponse, error) {
	path := "/v2/bot/audienceGroup/upload"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(createAudienceGroupRequest); err != nil {
		return nil, nil, err
	}
	log.Printf("Sending request: method=Post path=%s body=%s\n", path, buf.String())
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := CreateAudienceGroupResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// CreateClickBasedAudienceGroup
//
// Create audience for click-based retargeting
// Parameters:
//        createClickBasedAudienceGroupRequest

// https://developers.line.biz/en/reference/messaging-api/#create-click-audience-group
func (client *ManageAudienceAPI) CreateClickBasedAudienceGroup(

	createClickBasedAudienceGroupRequest *CreateClickBasedAudienceGroupRequest,

) (*CreateClickBasedAudienceGroupResponse, error) {
	_, body, error := client.CreateClickBasedAudienceGroupWithHttpInfo(

		createClickBasedAudienceGroupRequest,
	)
	return body, error
}

// CreateClickBasedAudienceGroup
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Create audience for click-based retargeting
// Parameters:
//        createClickBasedAudienceGroupRequest

// https://developers.line.biz/en/reference/messaging-api/#create-click-audience-group
func (client *ManageAudienceAPI) CreateClickBasedAudienceGroupWithHttpInfo(

	createClickBasedAudienceGroupRequest *CreateClickBasedAudienceGroupRequest,

) (*http.Response, *CreateClickBasedAudienceGroupResponse, error) {
	path := "/v2/bot/audienceGroup/click"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(createClickBasedAudienceGroupRequest); err != nil {
		return nil, nil, err
	}
	log.Printf("Sending request: method=Post path=%s body=%s\n", path, buf.String())
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := CreateClickBasedAudienceGroupResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// CreateImpBasedAudienceGroup
//
// Create audience for impression-based retargeting
// Parameters:
//        createImpBasedAudienceGroupRequest

// https://developers.line.biz/en/reference/messaging-api/#create-imp-audience-group
func (client *ManageAudienceAPI) CreateImpBasedAudienceGroup(

	createImpBasedAudienceGroupRequest *CreateImpBasedAudienceGroupRequest,

) (*CreateImpBasedAudienceGroupResponse, error) {
	_, body, error := client.CreateImpBasedAudienceGroupWithHttpInfo(

		createImpBasedAudienceGroupRequest,
	)
	return body, error
}

// CreateImpBasedAudienceGroup
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Create audience for impression-based retargeting
// Parameters:
//        createImpBasedAudienceGroupRequest

// https://developers.line.biz/en/reference/messaging-api/#create-imp-audience-group
func (client *ManageAudienceAPI) CreateImpBasedAudienceGroupWithHttpInfo(

	createImpBasedAudienceGroupRequest *CreateImpBasedAudienceGroupRequest,

) (*http.Response, *CreateImpBasedAudienceGroupResponse, error) {
	path := "/v2/bot/audienceGroup/imp"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(createImpBasedAudienceGroupRequest); err != nil {
		return nil, nil, err
	}
	log.Printf("Sending request: method=Post path=%s body=%s\n", path, buf.String())
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := CreateImpBasedAudienceGroupResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// DeleteAudienceGroup
//
// Delete audience
// Parameters:
//        audienceGroupId             The audience ID.

// https://developers.line.biz/en/reference/messaging-api/#delete-audience-group
func (client *ManageAudienceAPI) DeleteAudienceGroup(

	audienceGroupId int64,

) (struct{}, error) {
	_, body, error := client.DeleteAudienceGroupWithHttpInfo(

		audienceGroupId,
	)
	return body, error
}

// DeleteAudienceGroup
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Delete audience
// Parameters:
//        audienceGroupId             The audience ID.

// https://developers.line.biz/en/reference/messaging-api/#delete-audience-group
func (client *ManageAudienceAPI) DeleteAudienceGroupWithHttpInfo(

	audienceGroupId int64,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/audienceGroup/{audienceGroupId}"

	path = strings.Replace(path, "{audienceGroupId}", strconv.FormatInt(audienceGroupId, 10), -1)

	log.Printf("Sending request: method=Delete path=%s\n", path)
	req, err := http.NewRequest(http.MethodDelete, client.Url(path), nil)
	if err != nil {
		return nil, struct{}{}, err
	}

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// GetAudienceData
//
// Gets audience data.
// Parameters:
//        audienceGroupId             The audience ID.

// https://developers.line.biz/en/reference/messaging-api/#get-audience-group
func (client *ManageAudienceAPI) GetAudienceData(

	audienceGroupId int64,

) (*GetAudienceDataResponse, error) {
	_, body, error := client.GetAudienceDataWithHttpInfo(

		audienceGroupId,
	)
	return body, error
}

// GetAudienceData
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Gets audience data.
// Parameters:
//        audienceGroupId             The audience ID.

// https://developers.line.biz/en/reference/messaging-api/#get-audience-group
func (client *ManageAudienceAPI) GetAudienceDataWithHttpInfo(

	audienceGroupId int64,

) (*http.Response, *GetAudienceDataResponse, error) {
	path := "/v2/bot/audienceGroup/{audienceGroupId}"

	path = strings.Replace(path, "{audienceGroupId}", strconv.FormatInt(audienceGroupId, 10), -1)

	log.Printf("Sending request: method=Get path=%s\n", path)
	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GetAudienceDataResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetAudienceGroupAuthorityLevel
//
// Get the authority level of the audience
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-authority-level
func (client *ManageAudienceAPI) GetAudienceGroupAuthorityLevel() (*GetAudienceGroupAuthorityLevelResponse, error) {
	_, body, error := client.GetAudienceGroupAuthorityLevelWithHttpInfo()
	return body, error
}

// GetAudienceGroupAuthorityLevel
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get the authority level of the audience
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-authority-level
func (client *ManageAudienceAPI) GetAudienceGroupAuthorityLevelWithHttpInfo() (*http.Response, *GetAudienceGroupAuthorityLevelResponse, error) {
	path := "/v2/bot/audienceGroup/authorityLevel"

	log.Printf("Sending request: method=Get path=%s\n", path)
	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GetAudienceGroupAuthorityLevelResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetAudienceGroups
//
// Gets data for more than one audience.
// Parameters:
//        page             The page to return when getting (paginated) results. Must be 1 or higher.
//        description             The name of the audience(s) to return. You can search for partial matches. This is case-insensitive, meaning AUDIENCE and audience are considered identical. If omitted, the name of the audience(s) will not be used as a search criterion.
//        status             The status of the audience(s) to return. If omitted, the status of the audience(s) will not be used as a search criterion.
//        size             The number of audiences per page. Default: 20 Max: 40
//        includesExternalPublicGroups             true (default): Get public audiences created in all channels linked to the same bot. false: Get audiences created in the same channel.
//        createRoute             How the audience was created. If omitted, all audiences are included.  `OA_MANAGER`: Return only audiences created with LINE Official Account Manager (opens new window). `MESSAGING_API`: Return only audiences created with Messaging API.

// https://developers.line.biz/en/reference/messaging-api/#get-audience-groups
func (client *ManageAudienceAPI) GetAudienceGroups(

	page int64,

	description string,

	status AudienceGroupStatus,

	size int64,

	includesExternalPublicGroups bool,

	createRoute AudienceGroupCreateRoute,

) (*GetAudienceGroupsResponse, error) {
	_, body, error := client.GetAudienceGroupsWithHttpInfo(

		page,

		description,

		status,

		size,

		includesExternalPublicGroups,

		createRoute,
	)
	return body, error
}

// GetAudienceGroups
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Gets data for more than one audience.
// Parameters:
//        page             The page to return when getting (paginated) results. Must be 1 or higher.
//        description             The name of the audience(s) to return. You can search for partial matches. This is case-insensitive, meaning AUDIENCE and audience are considered identical. If omitted, the name of the audience(s) will not be used as a search criterion.
//        status             The status of the audience(s) to return. If omitted, the status of the audience(s) will not be used as a search criterion.
//        size             The number of audiences per page. Default: 20 Max: 40
//        includesExternalPublicGroups             true (default): Get public audiences created in all channels linked to the same bot. false: Get audiences created in the same channel.
//        createRoute             How the audience was created. If omitted, all audiences are included.  `OA_MANAGER`: Return only audiences created with LINE Official Account Manager (opens new window). `MESSAGING_API`: Return only audiences created with Messaging API.

// https://developers.line.biz/en/reference/messaging-api/#get-audience-groups
func (client *ManageAudienceAPI) GetAudienceGroupsWithHttpInfo(

	page int64,

	description string,

	status AudienceGroupStatus,

	size int64,

	includesExternalPublicGroups bool,

	createRoute AudienceGroupCreateRoute,

) (*http.Response, *GetAudienceGroupsResponse, error) {
	path := "/v2/bot/audienceGroup/list"

	log.Printf("Sending request: method=Get path=%s\n", path)
	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	var query url.Values
	query = url.Values{"page": []string{strconv.FormatInt(page, 10)}}
	query = url.Values{"description": []string{string(description)}}
	query = url.Values{"status": []string{string(status)}}
	query = url.Values{"size": []string{strconv.FormatInt(size, 10)}}
	query = url.Values{"includesExternalPublicGroups": []string{strconv.FormatBool(includesExternalPublicGroups)}}
	query = url.Values{"createRoute": []string{string(createRoute)}}

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GetAudienceGroupsResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// UpdateAudienceGroupAuthorityLevel
//
// Change the authority level of the audience
// Parameters:
//        updateAudienceGroupAuthorityLevelRequest

// https://developers.line.biz/en/reference/messaging-api/#change-authority-level
func (client *ManageAudienceAPI) UpdateAudienceGroupAuthorityLevel(

	updateAudienceGroupAuthorityLevelRequest *UpdateAudienceGroupAuthorityLevelRequest,

) (struct{}, error) {
	_, body, error := client.UpdateAudienceGroupAuthorityLevelWithHttpInfo(

		updateAudienceGroupAuthorityLevelRequest,
	)
	return body, error
}

// UpdateAudienceGroupAuthorityLevel
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Change the authority level of the audience
// Parameters:
//        updateAudienceGroupAuthorityLevelRequest

// https://developers.line.biz/en/reference/messaging-api/#change-authority-level
func (client *ManageAudienceAPI) UpdateAudienceGroupAuthorityLevelWithHttpInfo(

	updateAudienceGroupAuthorityLevelRequest *UpdateAudienceGroupAuthorityLevelRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/audienceGroup/authorityLevel"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(updateAudienceGroupAuthorityLevelRequest); err != nil {
		return nil, struct{}{}, err
	}
	log.Printf("Sending request: method=Put path=%s body=%s\n", path, buf.String())
	req, err := http.NewRequest(http.MethodPut, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// UpdateAudienceGroupDescription
//
// Renames an existing audience.
// Parameters:
//        audienceGroupId             The audience ID.
//        updateAudienceGroupDescriptionRequest

// https://developers.line.biz/en/reference/messaging-api/#set-description-audience-group
func (client *ManageAudienceAPI) UpdateAudienceGroupDescription(

	audienceGroupId int64,

	updateAudienceGroupDescriptionRequest *UpdateAudienceGroupDescriptionRequest,

) (struct{}, error) {
	_, body, error := client.UpdateAudienceGroupDescriptionWithHttpInfo(

		audienceGroupId,

		updateAudienceGroupDescriptionRequest,
	)
	return body, error
}

// UpdateAudienceGroupDescription
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Renames an existing audience.
// Parameters:
//        audienceGroupId             The audience ID.
//        updateAudienceGroupDescriptionRequest

// https://developers.line.biz/en/reference/messaging-api/#set-description-audience-group
func (client *ManageAudienceAPI) UpdateAudienceGroupDescriptionWithHttpInfo(

	audienceGroupId int64,

	updateAudienceGroupDescriptionRequest *UpdateAudienceGroupDescriptionRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/audienceGroup/{audienceGroupId}/updateDescription"

	path = strings.Replace(path, "{audienceGroupId}", strconv.FormatInt(audienceGroupId, 10), -1)

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(updateAudienceGroupDescriptionRequest); err != nil {
		return nil, struct{}{}, err
	}
	log.Printf("Sending request: method=Put path=%s body=%s\n", path, buf.String())
	req, err := http.NewRequest(http.MethodPut, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}
