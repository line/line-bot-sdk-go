/**
 * Webhook Type Definition
 * Webhook event definition of the LINE Messaging API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

//go:generate python3 ../../generate-code.py
package webhook

import (
	"encoding/json"
	"fmt"
)

type EventInterface interface {
	GetType() string
}

func (e Event) GetType() string {
	return e.Type
}

type UnknownEvent struct {
	EventInterface
	Type string
	Raw  map[string]json.RawMessage
}

func (e UnknownEvent) GetType() string {
	return e.Type
}

func setDiscriminatorPropertyEvent(r EventInterface) EventInterface {
	switch v := r.(type) {
	case *AccountLinkEvent:
		if v.Type == "" {
			v.Type = "accountLink"
		}
		return v
	case AccountLinkEvent:
		if v.Type == "" {
			v.Type = "accountLink"
		}
		return v
	case *ActivatedEvent:
		if v.Type == "" {
			v.Type = "activated"
		}
		return v
	case ActivatedEvent:
		if v.Type == "" {
			v.Type = "activated"
		}
		return v
	case *BeaconEvent:
		if v.Type == "" {
			v.Type = "beacon"
		}
		return v
	case BeaconEvent:
		if v.Type == "" {
			v.Type = "beacon"
		}
		return v
	case *BotResumedEvent:
		if v.Type == "" {
			v.Type = "botResumed"
		}
		return v
	case BotResumedEvent:
		if v.Type == "" {
			v.Type = "botResumed"
		}
		return v
	case *BotSuspendedEvent:
		if v.Type == "" {
			v.Type = "botSuspended"
		}
		return v
	case BotSuspendedEvent:
		if v.Type == "" {
			v.Type = "botSuspended"
		}
		return v
	case *DeactivatedEvent:
		if v.Type == "" {
			v.Type = "deactivated"
		}
		return v
	case DeactivatedEvent:
		if v.Type == "" {
			v.Type = "deactivated"
		}
		return v
	case *PnpDeliveryCompletionEvent:
		if v.Type == "" {
			v.Type = "delivery"
		}
		return v
	case PnpDeliveryCompletionEvent:
		if v.Type == "" {
			v.Type = "delivery"
		}
		return v
	case *FollowEvent:
		if v.Type == "" {
			v.Type = "follow"
		}
		return v
	case FollowEvent:
		if v.Type == "" {
			v.Type = "follow"
		}
		return v
	case *JoinEvent:
		if v.Type == "" {
			v.Type = "join"
		}
		return v
	case JoinEvent:
		if v.Type == "" {
			v.Type = "join"
		}
		return v
	case *LeaveEvent:
		if v.Type == "" {
			v.Type = "leave"
		}
		return v
	case LeaveEvent:
		if v.Type == "" {
			v.Type = "leave"
		}
		return v
	case *MemberJoinedEvent:
		if v.Type == "" {
			v.Type = "memberJoined"
		}
		return v
	case MemberJoinedEvent:
		if v.Type == "" {
			v.Type = "memberJoined"
		}
		return v
	case *MemberLeftEvent:
		if v.Type == "" {
			v.Type = "memberLeft"
		}
		return v
	case MemberLeftEvent:
		if v.Type == "" {
			v.Type = "memberLeft"
		}
		return v
	case *MessageEvent:
		if v.Type == "" {
			v.Type = "message"
		}
		return v
	case MessageEvent:
		if v.Type == "" {
			v.Type = "message"
		}
		return v
	case *ModuleEvent:
		if v.Type == "" {
			v.Type = "module"
		}
		return v
	case ModuleEvent:
		if v.Type == "" {
			v.Type = "module"
		}
		return v
	case *PostbackEvent:
		if v.Type == "" {
			v.Type = "postback"
		}
		return v
	case PostbackEvent:
		if v.Type == "" {
			v.Type = "postback"
		}
		return v
	case *ThingsEvent:
		if v.Type == "" {
			v.Type = "things"
		}
		return v
	case ThingsEvent:
		if v.Type == "" {
			v.Type = "things"
		}
		return v
	case *UnfollowEvent:
		if v.Type == "" {
			v.Type = "unfollow"
		}
		return v
	case UnfollowEvent:
		if v.Type == "" {
			v.Type = "unfollow"
		}
		return v
	case *UnsendEvent:
		if v.Type == "" {
			v.Type = "unsend"
		}
		return v
	case UnsendEvent:
		if v.Type == "" {
			v.Type = "unsend"
		}
		return v
	case *VideoPlayCompleteEvent:
		if v.Type == "" {
			v.Type = "videoPlayComplete"
		}
		return v
	case VideoPlayCompleteEvent:
		if v.Type == "" {
			v.Type = "videoPlayComplete"
		}
		return v

	default:
		return v
	}
}

// Event
// Webhook event

type Event struct {
	// Type of the event

	Type string `json:"type"`

	Source Source `json:"source,omitempty"`
	// Time of the event in milliseconds.

	Timestamp int64 `json:"timestamp"`

	Mode EventMode `json:"mode"`
	// Webhook Event ID. An ID that uniquely identifies a webhook event. This is a string in ULID format.

	WebhookEventId string `json:"webhookEventId"`

	DeliveryContext DeliveryContext `json:"deliveryContext"`
}

func UnmarshalEvent(data []byte) (EventInterface, error) {
	var raw map[string]json.RawMessage
	err := json.Unmarshal(data, &raw)
	if err != nil {
		return nil, fmt.Errorf("UnmarshalEvent: %w", err)
	}

	var discriminator string
	err = json.Unmarshal(raw["type"], &discriminator)
	if err != nil {
		return nil, fmt.Errorf("UnmarshalEvent: Cannot read type: %w", err)
	}

	switch discriminator {
	case "accountLink":
		var accountLink AccountLinkEvent
		if err := json.Unmarshal(data, &accountLink); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read accountLink: %w", err)
		}
		return accountLink, nil
	case "activated":
		var activated ActivatedEvent
		if err := json.Unmarshal(data, &activated); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read activated: %w", err)
		}
		return activated, nil
	case "beacon":
		var beacon BeaconEvent
		if err := json.Unmarshal(data, &beacon); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read beacon: %w", err)
		}
		return beacon, nil
	case "botResumed":
		var botResumed BotResumedEvent
		if err := json.Unmarshal(data, &botResumed); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read botResumed: %w", err)
		}
		return botResumed, nil
	case "botSuspended":
		var botSuspended BotSuspendedEvent
		if err := json.Unmarshal(data, &botSuspended); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read botSuspended: %w", err)
		}
		return botSuspended, nil
	case "deactivated":
		var deactivated DeactivatedEvent
		if err := json.Unmarshal(data, &deactivated); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read deactivated: %w", err)
		}
		return deactivated, nil
	case "delivery":
		var delivery PnpDeliveryCompletionEvent
		if err := json.Unmarshal(data, &delivery); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read delivery: %w", err)
		}
		return delivery, nil
	case "follow":
		var follow FollowEvent
		if err := json.Unmarshal(data, &follow); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read follow: %w", err)
		}
		return follow, nil
	case "join":
		var join JoinEvent
		if err := json.Unmarshal(data, &join); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read join: %w", err)
		}
		return join, nil
	case "leave":
		var leave LeaveEvent
		if err := json.Unmarshal(data, &leave); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read leave: %w", err)
		}
		return leave, nil
	case "memberJoined":
		var memberJoined MemberJoinedEvent
		if err := json.Unmarshal(data, &memberJoined); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read memberJoined: %w", err)
		}
		return memberJoined, nil
	case "memberLeft":
		var memberLeft MemberLeftEvent
		if err := json.Unmarshal(data, &memberLeft); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read memberLeft: %w", err)
		}
		return memberLeft, nil
	case "message":
		var message MessageEvent
		if err := json.Unmarshal(data, &message); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read message: %w", err)
		}
		return message, nil
	case "module":
		var module ModuleEvent
		if err := json.Unmarshal(data, &module); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read module: %w", err)
		}
		return module, nil
	case "postback":
		var postback PostbackEvent
		if err := json.Unmarshal(data, &postback); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read postback: %w", err)
		}
		return postback, nil
	case "things":
		var things ThingsEvent
		if err := json.Unmarshal(data, &things); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read things: %w", err)
		}
		return things, nil
	case "unfollow":
		var unfollow UnfollowEvent
		if err := json.Unmarshal(data, &unfollow); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read unfollow: %w", err)
		}
		return unfollow, nil
	case "unsend":
		var unsend UnsendEvent
		if err := json.Unmarshal(data, &unsend); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read unsend: %w", err)
		}
		return unsend, nil
	case "videoPlayComplete":
		var videoPlayComplete VideoPlayCompleteEvent
		if err := json.Unmarshal(data, &videoPlayComplete); err != nil {
			return nil, fmt.Errorf("UnmarshalEvent: Cannot read videoPlayComplete: %w", err)
		}
		return videoPlayComplete, nil

	default:
		var unknown UnknownEvent
		unknown.Type = discriminator
		unknown.Raw = raw
		return unknown, nil
	}
}
