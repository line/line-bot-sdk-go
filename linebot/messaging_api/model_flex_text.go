/**
 * LINE Messaging API
 * This document describes LINE Messaging API.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

//go:generate python3 ../../generate-code.py
package messaging_api

import (
	"encoding/json"
	"fmt"
)

// FlexText
// FlexText

type FlexText struct {
	FlexComponent

	/**
	 * Get Flex
	 */
	Flex int32 `json:"flex"`

	/**
	 * Get Text
	 */
	Text string `json:"text,omitempty"`

	/**
	 * Get Size
	 */
	Size string `json:"size,omitempty"`

	/**
	 * Get Align
	 */
	Align FlexTextALIGN `json:"align,omitempty"`

	/**
	 * Get Gravity
	 */
	Gravity FlexTextGRAVITY `json:"gravity,omitempty"`

	/**
	 * Get Color
	 */
	Color string `json:"color,omitempty"`

	/**
	 * Get Weight
	 */
	Weight FlexTextWEIGHT `json:"weight,omitempty"`

	/**
	 * Get Style
	 */
	Style FlexTextSTYLE `json:"style,omitempty"`

	/**
	 * Get Decoration
	 */
	Decoration FlexTextDECORATION `json:"decoration,omitempty"`

	/**
	 * Get Wrap
	 */
	Wrap bool `json:"wrap"`

	/**
	 * Get LineSpacing
	 */
	LineSpacing string `json:"lineSpacing,omitempty"`

	/**
	 * Get Margin
	 */
	Margin string `json:"margin,omitempty"`

	/**
	 * Get Position
	 */
	Position FlexTextPOSITION `json:"position,omitempty"`

	/**
	 * Get OffsetTop
	 */
	OffsetTop string `json:"offsetTop,omitempty"`

	/**
	 * Get OffsetBottom
	 */
	OffsetBottom string `json:"offsetBottom,omitempty"`

	/**
	 * Get OffsetStart
	 */
	OffsetStart string `json:"offsetStart,omitempty"`

	/**
	 * Get OffsetEnd
	 */
	OffsetEnd string `json:"offsetEnd,omitempty"`

	/**
	 * Get Action
	 */
	Action ActionInterface `json:"action,omitempty"`

	/**
	 * Get MaxLines
	 */
	MaxLines int32 `json:"maxLines"`

	/**
	 * Get Contents
	 */
	Contents []FlexSpan `json:"contents,omitempty"`

	/**
	 * Get AdjustMode
	 */
	AdjustMode FlexTextADJUST_MODE `json:"adjustMode,omitempty"`

	/**
	 * Get Scaling
	 */
	Scaling bool `json:"scaling"`
}

func (cr *FlexText) UnmarshalJSON(data []byte) error {
	var raw map[string]json.RawMessage
	err := json.Unmarshal(data, &raw)
	if err != nil {
		return fmt.Errorf("JSON parse error in map: %w", err)
	}

	if raw["type"] != nil {

		err = json.Unmarshal(raw["type"], &cr.Type)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Type): %w", err)
		}

	}

	if raw["flex"] != nil {

		err = json.Unmarshal(raw["flex"], &cr.Flex)
		if err != nil {
			return fmt.Errorf("JSON parse error in int32(Flex): %w", err)
		}

	}

	if raw["text"] != nil {

		err = json.Unmarshal(raw["text"], &cr.Text)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Text): %w", err)
		}

	}

	if raw["size"] != nil {

		err = json.Unmarshal(raw["size"], &cr.Size)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Size): %w", err)
		}

	}

	if raw["align"] != nil {

		err = json.Unmarshal(raw["align"], &cr.Align)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Align): %w", err)
		}

	}

	if raw["gravity"] != nil {

		err = json.Unmarshal(raw["gravity"], &cr.Gravity)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Gravity): %w", err)
		}

	}

	if raw["color"] != nil {

		err = json.Unmarshal(raw["color"], &cr.Color)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Color): %w", err)
		}

	}

	if raw["weight"] != nil {

		err = json.Unmarshal(raw["weight"], &cr.Weight)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Weight): %w", err)
		}

	}

	if raw["style"] != nil {

		err = json.Unmarshal(raw["style"], &cr.Style)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Style): %w", err)
		}

	}

	if raw["decoration"] != nil {

		err = json.Unmarshal(raw["decoration"], &cr.Decoration)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Decoration): %w", err)
		}

	}

	if raw["wrap"] != nil {

		err = json.Unmarshal(raw["wrap"], &cr.Wrap)
		if err != nil {
			return fmt.Errorf("JSON parse error in bool(Wrap): %w", err)
		}

	}

	if raw["lineSpacing"] != nil {

		err = json.Unmarshal(raw["lineSpacing"], &cr.LineSpacing)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(LineSpacing): %w", err)
		}

	}

	if raw["margin"] != nil {

		err = json.Unmarshal(raw["margin"], &cr.Margin)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Margin): %w", err)
		}

	}

	if raw["position"] != nil {

		err = json.Unmarshal(raw["position"], &cr.Position)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Position): %w", err)
		}

	}

	if raw["offsetTop"] != nil {

		err = json.Unmarshal(raw["offsetTop"], &cr.OffsetTop)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(OffsetTop): %w", err)
		}

	}

	if raw["offsetBottom"] != nil {

		err = json.Unmarshal(raw["offsetBottom"], &cr.OffsetBottom)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(OffsetBottom): %w", err)
		}

	}

	if raw["offsetStart"] != nil {

		err = json.Unmarshal(raw["offsetStart"], &cr.OffsetStart)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(OffsetStart): %w", err)
		}

	}

	if raw["offsetEnd"] != nil {

		err = json.Unmarshal(raw["offsetEnd"], &cr.OffsetEnd)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(OffsetEnd): %w", err)
		}

	}

	if raw["action"] != nil {

		if rawaction, ok := raw["action"]; ok && rawaction != nil {
			Action, err := UnmarshalAction(rawaction)
			if err != nil {
				return fmt.Errorf("JSON parse error in Action(discriminator): %w", err)
			}
			cr.Action = Action
		}

	}

	if raw["maxLines"] != nil {

		err = json.Unmarshal(raw["maxLines"], &cr.MaxLines)
		if err != nil {
			return fmt.Errorf("JSON parse error in int32(MaxLines): %w", err)
		}

	}

	if raw["contents"] != nil {

		err = json.Unmarshal(raw["contents"], &cr.Contents)
		if err != nil {
			return fmt.Errorf("JSON parse error in array(Contents): %w", err)
		}

	}

	if raw["adjustMode"] != nil {

		err = json.Unmarshal(raw["adjustMode"], &cr.AdjustMode)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(AdjustMode): %w", err)
		}

	}

	if raw["scaling"] != nil {

		err = json.Unmarshal(raw["scaling"], &cr.Scaling)
		if err != nil {
			return fmt.Errorf("JSON parse error in bool(Scaling): %w", err)
		}

	}

	return nil
}

// MarshalJSON customizes the JSON serialization of the FlexText struct.
func (r *FlexText) MarshalJSON() ([]byte, error) {

	r.Action = setDiscriminatorPropertyAction(r.Action)

	type Alias FlexText
	return json.Marshal(&struct {
		*Alias

		Type string `json:"type"`
	}{
		Alias: (*Alias)(r),

		Type: "text",
	})
}

// FlexTextALIGN type

type FlexTextALIGN string

// FlexTextALIGN constants
const (
	FlexTextALIGN_START FlexTextALIGN = "start"

	FlexTextALIGN_END FlexTextALIGN = "end"

	FlexTextALIGN_CENTER FlexTextALIGN = "center"
)

// FlexTextGRAVITY type

type FlexTextGRAVITY string

// FlexTextGRAVITY constants
const (
	FlexTextGRAVITY_TOP FlexTextGRAVITY = "top"

	FlexTextGRAVITY_BOTTOM FlexTextGRAVITY = "bottom"

	FlexTextGRAVITY_CENTER FlexTextGRAVITY = "center"
)

// FlexTextWEIGHT type

type FlexTextWEIGHT string

// FlexTextWEIGHT constants
const (
	FlexTextWEIGHT_REGULAR FlexTextWEIGHT = "regular"

	FlexTextWEIGHT_BOLD FlexTextWEIGHT = "bold"
)

// FlexTextSTYLE type

type FlexTextSTYLE string

// FlexTextSTYLE constants
const (
	FlexTextSTYLE_NORMAL FlexTextSTYLE = "normal"

	FlexTextSTYLE_ITALIC FlexTextSTYLE = "italic"
)

// FlexTextDECORATION type

type FlexTextDECORATION string

// FlexTextDECORATION constants
const (
	FlexTextDECORATION_NONE FlexTextDECORATION = "none"

	FlexTextDECORATION_UNDERLINE FlexTextDECORATION = "underline"

	FlexTextDECORATION_LINE_THROUGH FlexTextDECORATION = "line-through"
)

// FlexTextPOSITION type

type FlexTextPOSITION string

// FlexTextPOSITION constants
const (
	FlexTextPOSITION_RELATIVE FlexTextPOSITION = "relative"

	FlexTextPOSITION_ABSOLUTE FlexTextPOSITION = "absolute"
)

// FlexTextADJUST_MODE type

type FlexTextADJUST_MODE string

// FlexTextADJUST_MODE constants
const (
	FlexTextADJUST_MODE_SHRINK_TO_FIT FlexTextADJUST_MODE = "shrink-to-fit"
)
