/**
 * LINE Messaging API
 * This document describes LINE Messaging API.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

//go:generate python3 ../../generate-code.py

package messaging_api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strconv"
	"strings"

	"github.com/line/line-bot-sdk-go/v8/linebot"
)

type MessagingApiAPI struct {
	httpClient   *http.Client
	endpoint     *url.URL
	channelToken string
	ctx          context.Context
}

// MessagingApiAPIOption type
type MessagingApiAPIOption func(*MessagingApiAPI) error

// New returns a new bot client instance.
func NewMessagingApiAPI(channelToken string, options ...MessagingApiAPIOption) (*MessagingApiAPI, error) {
	if channelToken == "" {
		return nil, errors.New("missing channel access token")
	}

	c := &MessagingApiAPI{
		channelToken: channelToken,
		httpClient:   http.DefaultClient,
	}

	u, err := url.ParseRequestURI("https://api.line.me")
	if err != nil {
		return nil, err
	}
	c.endpoint = u

	for _, option := range options {
		err := option(c)
		if err != nil {
			return nil, err
		}
	}
	return c, nil
}

// WithContext method
func (call *MessagingApiAPI) WithContext(ctx context.Context) *MessagingApiAPI {
	call.ctx = ctx
	return call
}

func (client *MessagingApiAPI) Do(req *http.Request) (*http.Response, error) {
	if client.channelToken != "" {
		req.Header.Set("Authorization", "Bearer "+client.channelToken)
	}
	req.Header.Set("User-Agent", "LINE-BotSDK-Go/"+linebot.GetVersion())
	if client.ctx != nil {
		req = req.WithContext(client.ctx)
	}
	return client.httpClient.Do(req)
}

func (client *MessagingApiAPI) Url(endpointPath string) string {
	newPath := path.Join(client.endpoint.Path, endpointPath)
	u := *client.endpoint
	u.Path = newPath
	return u.String()
}

// WithHTTPClient function
func WithHTTPClient(c *http.Client) MessagingApiAPIOption {
	return func(client *MessagingApiAPI) error {
		client.httpClient = c
		return nil
	}
}

// WithEndpointClient function
func WithEndpoint(endpoint string) MessagingApiAPIOption {
	return func(client *MessagingApiAPI) error {
		u, err := url.ParseRequestURI(endpoint)
		if err != nil {
			return err
		}
		client.endpoint = u
		return nil
	}
}

// AudienceMatch
//
// Send a message using phone number
// Parameters:
//        audienceMatchMessagesRequest

// https://developers.line.biz/en/reference/partner-docs/#phone-audience-match
func (client *MessagingApiAPI) AudienceMatch(

	audienceMatchMessagesRequest *AudienceMatchMessagesRequest,

) (struct{}, error) {
	_, body, error := client.AudienceMatchWithHttpInfo(

		audienceMatchMessagesRequest,
	)
	return body, error
}

// AudienceMatch
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Send a message using phone number
// Parameters:
//        audienceMatchMessagesRequest

// https://developers.line.biz/en/reference/partner-docs/#phone-audience-match
func (client *MessagingApiAPI) AudienceMatchWithHttpInfo(

	audienceMatchMessagesRequest *AudienceMatchMessagesRequest,

) (*http.Response, struct{}, error) {
	path := "/bot/ad/multicast/phone"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(audienceMatchMessagesRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// Broadcast
//
// Sends a message to multiple users at any time.
// Parameters:
//        broadcastRequest
//        xLineRetryKey             Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.

// https://developers.line.biz/en/reference/messaging-api/#send-broadcast-message
func (client *MessagingApiAPI) Broadcast(

	broadcastRequest *BroadcastRequest,

	xLineRetryKey string,

) (*map[string]interface{}, error) {
	_, body, error := client.BroadcastWithHttpInfo(

		broadcastRequest,

		xLineRetryKey,
	)
	return body, error
}

// Broadcast
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Sends a message to multiple users at any time.
// Parameters:
//        broadcastRequest
//        xLineRetryKey             Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.

// https://developers.line.biz/en/reference/messaging-api/#send-broadcast-message
func (client *MessagingApiAPI) BroadcastWithHttpInfo(

	broadcastRequest *BroadcastRequest,

	xLineRetryKey string,

) (*http.Response, *map[string]interface{}, error) {
	path := "/v2/bot/message/broadcast"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(broadcastRequest); err != nil {
		return nil, nil, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	req.Header.Set("X-Line-Retry-Key", xLineRetryKey)

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := map[string]interface{}{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// CancelDefaultRichMenu
//
// Cancel default rich menu
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#cancel-default-rich-menu
func (client *MessagingApiAPI) CancelDefaultRichMenu() (struct{}, error) {
	_, body, error := client.CancelDefaultRichMenuWithHttpInfo()
	return body, error
}

// CancelDefaultRichMenu
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Cancel default rich menu
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#cancel-default-rich-menu
func (client *MessagingApiAPI) CancelDefaultRichMenuWithHttpInfo() (*http.Response, struct{}, error) {
	path := "/v2/bot/user/all/richmenu"

	req, err := http.NewRequest(http.MethodDelete, client.Url(path), nil)
	if err != nil {
		return nil, struct{}{}, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// CreateRichMenu
//
// Create rich menu
// Parameters:
//        richMenuRequest

// https://developers.line.biz/en/reference/messaging-api/#create-rich-menu
func (client *MessagingApiAPI) CreateRichMenu(

	richMenuRequest *RichMenuRequest,

) (*RichMenuIdResponse, error) {
	_, body, error := client.CreateRichMenuWithHttpInfo(

		richMenuRequest,
	)
	return body, error
}

// CreateRichMenu
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Create rich menu
// Parameters:
//        richMenuRequest

// https://developers.line.biz/en/reference/messaging-api/#create-rich-menu
func (client *MessagingApiAPI) CreateRichMenuWithHttpInfo(

	richMenuRequest *RichMenuRequest,

) (*http.Response, *RichMenuIdResponse, error) {
	path := "/v2/bot/richmenu"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(richMenuRequest); err != nil {
		return nil, nil, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := RichMenuIdResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// CreateRichMenuAlias
//
// Create rich menu alias
// Parameters:
//        createRichMenuAliasRequest

// https://developers.line.biz/en/reference/messaging-api/#create-rich-menu-alias
func (client *MessagingApiAPI) CreateRichMenuAlias(

	createRichMenuAliasRequest *CreateRichMenuAliasRequest,

) (struct{}, error) {
	_, body, error := client.CreateRichMenuAliasWithHttpInfo(

		createRichMenuAliasRequest,
	)
	return body, error
}

// CreateRichMenuAlias
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Create rich menu alias
// Parameters:
//        createRichMenuAliasRequest

// https://developers.line.biz/en/reference/messaging-api/#create-rich-menu-alias
func (client *MessagingApiAPI) CreateRichMenuAliasWithHttpInfo(

	createRichMenuAliasRequest *CreateRichMenuAliasRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/richmenu/alias"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(createRichMenuAliasRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// DeleteRichMenu
//
// Deletes a rich menu.
// Parameters:
//        richMenuId             ID of a rich menu

// https://developers.line.biz/en/reference/messaging-api/#delete-rich-menu
func (client *MessagingApiAPI) DeleteRichMenu(

	richMenuId string,

) (struct{}, error) {
	_, body, error := client.DeleteRichMenuWithHttpInfo(

		richMenuId,
	)
	return body, error
}

// DeleteRichMenu
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Deletes a rich menu.
// Parameters:
//        richMenuId             ID of a rich menu

// https://developers.line.biz/en/reference/messaging-api/#delete-rich-menu
func (client *MessagingApiAPI) DeleteRichMenuWithHttpInfo(

	richMenuId string,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/richmenu/{richMenuId}"

	path = strings.Replace(path, "{richMenuId}", richMenuId, -1)

	req, err := http.NewRequest(http.MethodDelete, client.Url(path), nil)
	if err != nil {
		return nil, struct{}{}, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// DeleteRichMenuAlias
//
// Delete rich menu alias
// Parameters:
//        richMenuAliasId             Rich menu alias ID that you want to delete.

// https://developers.line.biz/en/reference/messaging-api/#delete-rich-menu-alias
func (client *MessagingApiAPI) DeleteRichMenuAlias(

	richMenuAliasId string,

) (struct{}, error) {
	_, body, error := client.DeleteRichMenuAliasWithHttpInfo(

		richMenuAliasId,
	)
	return body, error
}

// DeleteRichMenuAlias
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Delete rich menu alias
// Parameters:
//        richMenuAliasId             Rich menu alias ID that you want to delete.

// https://developers.line.biz/en/reference/messaging-api/#delete-rich-menu-alias
func (client *MessagingApiAPI) DeleteRichMenuAliasWithHttpInfo(

	richMenuAliasId string,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/richmenu/alias/{richMenuAliasId}"

	path = strings.Replace(path, "{richMenuAliasId}", richMenuAliasId, -1)

	req, err := http.NewRequest(http.MethodDelete, client.Url(path), nil)
	if err != nil {
		return nil, struct{}{}, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// GetAdPhoneMessageStatistics
//
// Get result of message delivery using phone number
// Parameters:
//        date             Date the message was sent  Format: `yyyyMMdd` (e.g. `20190831`) Time Zone: UTC+9

// https://developers.line.biz/en/reference/partner-docs/#get-phone-audience-match
func (client *MessagingApiAPI) GetAdPhoneMessageStatistics(

	date string,

) (*NumberOfMessagesResponse, error) {
	_, body, error := client.GetAdPhoneMessageStatisticsWithHttpInfo(

		date,
	)
	return body, error
}

// GetAdPhoneMessageStatistics
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get result of message delivery using phone number
// Parameters:
//        date             Date the message was sent  Format: `yyyyMMdd` (e.g. `20190831`) Time Zone: UTC+9

// https://developers.line.biz/en/reference/partner-docs/#get-phone-audience-match
func (client *MessagingApiAPI) GetAdPhoneMessageStatisticsWithHttpInfo(

	date string,

) (*http.Response, *NumberOfMessagesResponse, error) {
	path := "/v2/bot/message/delivery/ad_phone"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	query.Add("date", date)

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := NumberOfMessagesResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetAggregationUnitNameList
//
// Get name list of units used this month
// Parameters:
//        limit             The maximum number of aggregation units you can get per request.
//        start             Value of the continuation token found in the next property of the JSON object returned in the response. If you can't get all the aggregation units in one request, include this parameter to get the remaining array.

// https://developers.line.biz/en/reference/messaging-api/#get-name-list-of-units-used-this-month
func (client *MessagingApiAPI) GetAggregationUnitNameList(

	limit string,

	start string,

) (*GetAggregationUnitNameListResponse, error) {
	_, body, error := client.GetAggregationUnitNameListWithHttpInfo(

		limit,

		start,
	)
	return body, error
}

// GetAggregationUnitNameList
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get name list of units used this month
// Parameters:
//        limit             The maximum number of aggregation units you can get per request.
//        start             Value of the continuation token found in the next property of the JSON object returned in the response. If you can't get all the aggregation units in one request, include this parameter to get the remaining array.

// https://developers.line.biz/en/reference/messaging-api/#get-name-list-of-units-used-this-month
func (client *MessagingApiAPI) GetAggregationUnitNameListWithHttpInfo(

	limit string,

	start string,

) (*http.Response, *GetAggregationUnitNameListResponse, error) {
	path := "/v2/bot/message/aggregation/list"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	if limit != "" {
		query.Add("limit", limit)
	}
	if start != "" {
		query.Add("start", start)
	}

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GetAggregationUnitNameListResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetAggregationUnitUsage
//
// Get number of units used this month
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-number-of-units-used-this-month
func (client *MessagingApiAPI) GetAggregationUnitUsage() (*GetAggregationUnitUsageResponse, error) {
	_, body, error := client.GetAggregationUnitUsageWithHttpInfo()
	return body, error
}

// GetAggregationUnitUsage
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get number of units used this month
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-number-of-units-used-this-month
func (client *MessagingApiAPI) GetAggregationUnitUsageWithHttpInfo() (*http.Response, *GetAggregationUnitUsageResponse, error) {
	path := "/v2/bot/message/aggregation/info"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GetAggregationUnitUsageResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetBotInfo
//
// Get bot info
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-bot-info
func (client *MessagingApiAPI) GetBotInfo() (*BotInfoResponse, error) {
	_, body, error := client.GetBotInfoWithHttpInfo()
	return body, error
}

// GetBotInfo
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get bot info
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-bot-info
func (client *MessagingApiAPI) GetBotInfoWithHttpInfo() (*http.Response, *BotInfoResponse, error) {
	path := "/v2/bot/info"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := BotInfoResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetDefaultRichMenuId
//
// Gets the ID of the default rich menu set with the Messaging API.
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-default-rich-menu-id
func (client *MessagingApiAPI) GetDefaultRichMenuId() (*RichMenuIdResponse, error) {
	_, body, error := client.GetDefaultRichMenuIdWithHttpInfo()
	return body, error
}

// GetDefaultRichMenuId
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Gets the ID of the default rich menu set with the Messaging API.
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-default-rich-menu-id
func (client *MessagingApiAPI) GetDefaultRichMenuIdWithHttpInfo() (*http.Response, *RichMenuIdResponse, error) {
	path := "/v2/bot/user/all/richmenu"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := RichMenuIdResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetFollowers
//
// Get a list of users who added your LINE Official Account as a friend
// Parameters:
//        start             Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs.
//        limit             The maximum number of user IDs to retrieve in a single request.

// https://developers.line.biz/en/reference/messaging-api/#get-follower-ids
func (client *MessagingApiAPI) GetFollowers(

	start string,

	limit int32,

) (*GetFollowersResponse, error) {
	_, body, error := client.GetFollowersWithHttpInfo(

		start,

		limit,
	)
	return body, error
}

// GetFollowers
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get a list of users who added your LINE Official Account as a friend
// Parameters:
//        start             Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs.
//        limit             The maximum number of user IDs to retrieve in a single request.

// https://developers.line.biz/en/reference/messaging-api/#get-follower-ids
func (client *MessagingApiAPI) GetFollowersWithHttpInfo(

	start string,

	limit int32,

) (*http.Response, *GetFollowersResponse, error) {
	path := "/v2/bot/followers/ids"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	if start != "" {
		query.Add("start", start)
	}
	query.Add("limit", strconv.FormatInt(int64(limit), 10))

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GetFollowersResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetGroupMemberCount
//
// Get number of users in a group chat
// Parameters:
//        groupId             Group ID

// https://developers.line.biz/en/reference/messaging-api/#get-members-group-count
func (client *MessagingApiAPI) GetGroupMemberCount(

	groupId string,

) (*GroupMemberCountResponse, error) {
	_, body, error := client.GetGroupMemberCountWithHttpInfo(

		groupId,
	)
	return body, error
}

// GetGroupMemberCount
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get number of users in a group chat
// Parameters:
//        groupId             Group ID

// https://developers.line.biz/en/reference/messaging-api/#get-members-group-count
func (client *MessagingApiAPI) GetGroupMemberCountWithHttpInfo(

	groupId string,

) (*http.Response, *GroupMemberCountResponse, error) {
	path := "/v2/bot/group/{groupId}/members/count"

	path = strings.Replace(path, "{groupId}", groupId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GroupMemberCountResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetGroupMemberProfile
//
// Get group chat member profile
// Parameters:
//        groupId             Group ID
//        userId             User ID

// https://developers.line.biz/en/reference/messaging-api/#get-group-member-profile
func (client *MessagingApiAPI) GetGroupMemberProfile(

	groupId string,

	userId string,

) (*GroupUserProfileResponse, error) {
	_, body, error := client.GetGroupMemberProfileWithHttpInfo(

		groupId,

		userId,
	)
	return body, error
}

// GetGroupMemberProfile
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get group chat member profile
// Parameters:
//        groupId             Group ID
//        userId             User ID

// https://developers.line.biz/en/reference/messaging-api/#get-group-member-profile
func (client *MessagingApiAPI) GetGroupMemberProfileWithHttpInfo(

	groupId string,

	userId string,

) (*http.Response, *GroupUserProfileResponse, error) {
	path := "/v2/bot/group/{groupId}/member/{userId}"

	path = strings.Replace(path, "{groupId}", groupId, -1)

	path = strings.Replace(path, "{userId}", userId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GroupUserProfileResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetGroupMembersIds
//
// Get group chat member user IDs
// Parameters:
//        groupId             Group ID
//        start             Value of the continuation token found in the `next` property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group.

// https://developers.line.biz/en/reference/messaging-api/#get-group-member-user-ids
func (client *MessagingApiAPI) GetGroupMembersIds(

	groupId string,

	start string,

) (*MembersIdsResponse, error) {
	_, body, error := client.GetGroupMembersIdsWithHttpInfo(

		groupId,

		start,
	)
	return body, error
}

// GetGroupMembersIds
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get group chat member user IDs
// Parameters:
//        groupId             Group ID
//        start             Value of the continuation token found in the `next` property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group.

// https://developers.line.biz/en/reference/messaging-api/#get-group-member-user-ids
func (client *MessagingApiAPI) GetGroupMembersIdsWithHttpInfo(

	groupId string,

	start string,

) (*http.Response, *MembersIdsResponse, error) {
	path := "/v2/bot/group/{groupId}/members/ids"

	path = strings.Replace(path, "{groupId}", groupId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	if start != "" {
		query.Add("start", start)
	}

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := MembersIdsResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetGroupSummary
//
// Get group chat summary
// Parameters:
//        groupId             Group ID

// https://developers.line.biz/en/reference/messaging-api/#get-group-summary
func (client *MessagingApiAPI) GetGroupSummary(

	groupId string,

) (*GroupSummaryResponse, error) {
	_, body, error := client.GetGroupSummaryWithHttpInfo(

		groupId,
	)
	return body, error
}

// GetGroupSummary
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get group chat summary
// Parameters:
//        groupId             Group ID

// https://developers.line.biz/en/reference/messaging-api/#get-group-summary
func (client *MessagingApiAPI) GetGroupSummaryWithHttpInfo(

	groupId string,

) (*http.Response, *GroupSummaryResponse, error) {
	path := "/v2/bot/group/{groupId}/summary"

	path = strings.Replace(path, "{groupId}", groupId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GroupSummaryResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetMembershipList
//
// Get a list of memberships.
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-membership-plans
func (client *MessagingApiAPI) GetMembershipList() (*MembershipListResponse, error) {
	_, body, error := client.GetMembershipListWithHttpInfo()
	return body, error
}

// GetMembershipList
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get a list of memberships.
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-membership-plans
func (client *MessagingApiAPI) GetMembershipListWithHttpInfo() (*http.Response, *MembershipListResponse, error) {
	path := "/v2/bot/membership/list"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := MembershipListResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetMembershipSubscription
//
// Get a user's membership subscription.
// Parameters:
//        userId             User ID

// https://developers.line.biz/en/reference/messaging-api/#get-a-users-membership-subscription-status
func (client *MessagingApiAPI) GetMembershipSubscription(

	userId string,

) (*GetMembershipSubscriptionResponse, error) {
	_, body, error := client.GetMembershipSubscriptionWithHttpInfo(

		userId,
	)
	return body, error
}

// GetMembershipSubscription
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get a user's membership subscription.
// Parameters:
//        userId             User ID

// https://developers.line.biz/en/reference/messaging-api/#get-a-users-membership-subscription-status
func (client *MessagingApiAPI) GetMembershipSubscriptionWithHttpInfo(

	userId string,

) (*http.Response, *GetMembershipSubscriptionResponse, error) {
	path := "/v2/bot/membership/subscription/{userId}"

	path = strings.Replace(path, "{userId}", userId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GetMembershipSubscriptionResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetMessageQuota
//
// Gets the target limit for sending messages in the current month. The total number of the free messages and the additional messages is returned.
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-quota
func (client *MessagingApiAPI) GetMessageQuota() (*MessageQuotaResponse, error) {
	_, body, error := client.GetMessageQuotaWithHttpInfo()
	return body, error
}

// GetMessageQuota
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Gets the target limit for sending messages in the current month. The total number of the free messages and the additional messages is returned.
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-quota
func (client *MessagingApiAPI) GetMessageQuotaWithHttpInfo() (*http.Response, *MessageQuotaResponse, error) {
	path := "/v2/bot/message/quota"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := MessageQuotaResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetMessageQuotaConsumption
//
// Gets the number of messages sent in the current month.
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-consumption
func (client *MessagingApiAPI) GetMessageQuotaConsumption() (*QuotaConsumptionResponse, error) {
	_, body, error := client.GetMessageQuotaConsumptionWithHttpInfo()
	return body, error
}

// GetMessageQuotaConsumption
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Gets the number of messages sent in the current month.
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-consumption
func (client *MessagingApiAPI) GetMessageQuotaConsumptionWithHttpInfo() (*http.Response, *QuotaConsumptionResponse, error) {
	path := "/v2/bot/message/quota/consumption"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := QuotaConsumptionResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetNarrowcastProgress
//
// Gets the status of a narrowcast message.
// Parameters:
//        requestId             The narrowcast message's request ID. Each Messaging API request has a request ID.

// https://developers.line.biz/en/reference/messaging-api/#get-narrowcast-progress-status
func (client *MessagingApiAPI) GetNarrowcastProgress(

	requestId string,

) (*NarrowcastProgressResponse, error) {
	_, body, error := client.GetNarrowcastProgressWithHttpInfo(

		requestId,
	)
	return body, error
}

// GetNarrowcastProgress
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Gets the status of a narrowcast message.
// Parameters:
//        requestId             The narrowcast message's request ID. Each Messaging API request has a request ID.

// https://developers.line.biz/en/reference/messaging-api/#get-narrowcast-progress-status
func (client *MessagingApiAPI) GetNarrowcastProgressWithHttpInfo(

	requestId string,

) (*http.Response, *NarrowcastProgressResponse, error) {
	path := "/v2/bot/message/progress/narrowcast"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	query.Add("requestId", requestId)

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := NarrowcastProgressResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetNumberOfSentBroadcastMessages
//
// Get number of sent broadcast messages
// Parameters:
//        date             Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9

// https://developers.line.biz/en/reference/messaging-api/#get-number-of-broadcast-messages
func (client *MessagingApiAPI) GetNumberOfSentBroadcastMessages(

	date string,

) (*NumberOfMessagesResponse, error) {
	_, body, error := client.GetNumberOfSentBroadcastMessagesWithHttpInfo(

		date,
	)
	return body, error
}

// GetNumberOfSentBroadcastMessages
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get number of sent broadcast messages
// Parameters:
//        date             Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9

// https://developers.line.biz/en/reference/messaging-api/#get-number-of-broadcast-messages
func (client *MessagingApiAPI) GetNumberOfSentBroadcastMessagesWithHttpInfo(

	date string,

) (*http.Response, *NumberOfMessagesResponse, error) {
	path := "/v2/bot/message/delivery/broadcast"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	query.Add("date", date)

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := NumberOfMessagesResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetNumberOfSentMulticastMessages
//
// Get number of sent multicast messages
// Parameters:
//        date             Date the messages were sent  Format: `yyyyMMdd` (e.g. `20191231`) Timezone: UTC+9

// https://developers.line.biz/en/reference/messaging-api/#get-number-of-multicast-messages
func (client *MessagingApiAPI) GetNumberOfSentMulticastMessages(

	date string,

) (*NumberOfMessagesResponse, error) {
	_, body, error := client.GetNumberOfSentMulticastMessagesWithHttpInfo(

		date,
	)
	return body, error
}

// GetNumberOfSentMulticastMessages
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get number of sent multicast messages
// Parameters:
//        date             Date the messages were sent  Format: `yyyyMMdd` (e.g. `20191231`) Timezone: UTC+9

// https://developers.line.biz/en/reference/messaging-api/#get-number-of-multicast-messages
func (client *MessagingApiAPI) GetNumberOfSentMulticastMessagesWithHttpInfo(

	date string,

) (*http.Response, *NumberOfMessagesResponse, error) {
	path := "/v2/bot/message/delivery/multicast"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	query.Add("date", date)

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := NumberOfMessagesResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetNumberOfSentPushMessages
//
// Get number of sent push messages
// Parameters:
//        date             Date the messages were sent  Format: `yyyyMMdd` (e.g. `20191231`) Timezone: UTC+9

// https://developers.line.biz/en/reference/messaging-api/#get-number-of-push-messages
func (client *MessagingApiAPI) GetNumberOfSentPushMessages(

	date string,

) (*NumberOfMessagesResponse, error) {
	_, body, error := client.GetNumberOfSentPushMessagesWithHttpInfo(

		date,
	)
	return body, error
}

// GetNumberOfSentPushMessages
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get number of sent push messages
// Parameters:
//        date             Date the messages were sent  Format: `yyyyMMdd` (e.g. `20191231`) Timezone: UTC+9

// https://developers.line.biz/en/reference/messaging-api/#get-number-of-push-messages
func (client *MessagingApiAPI) GetNumberOfSentPushMessagesWithHttpInfo(

	date string,

) (*http.Response, *NumberOfMessagesResponse, error) {
	path := "/v2/bot/message/delivery/push"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	query.Add("date", date)

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := NumberOfMessagesResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetNumberOfSentReplyMessages
//
// Get number of sent reply messages
// Parameters:
//        date             Date the messages were sent  Format: `yyyyMMdd` (e.g. `20191231`) Timezone: UTC+9

// https://developers.line.biz/en/reference/messaging-api/#get-number-of-reply-messages
func (client *MessagingApiAPI) GetNumberOfSentReplyMessages(

	date string,

) (*NumberOfMessagesResponse, error) {
	_, body, error := client.GetNumberOfSentReplyMessagesWithHttpInfo(

		date,
	)
	return body, error
}

// GetNumberOfSentReplyMessages
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get number of sent reply messages
// Parameters:
//        date             Date the messages were sent  Format: `yyyyMMdd` (e.g. `20191231`) Timezone: UTC+9

// https://developers.line.biz/en/reference/messaging-api/#get-number-of-reply-messages
func (client *MessagingApiAPI) GetNumberOfSentReplyMessagesWithHttpInfo(

	date string,

) (*http.Response, *NumberOfMessagesResponse, error) {
	path := "/v2/bot/message/delivery/reply"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	query.Add("date", date)

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := NumberOfMessagesResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetPNPMessageStatistics
//
// Get number of sent LINE notification messages
// Parameters:
//        date             Date the message was sent  Format: `yyyyMMdd` (Example:`20211231`) Time zone: UTC+9

// https://developers.line.biz/en/reference/partner-docs/#get-number-of-sent-line-notification-messages
func (client *MessagingApiAPI) GetPNPMessageStatistics(

	date string,

) (*NumberOfMessagesResponse, error) {
	_, body, error := client.GetPNPMessageStatisticsWithHttpInfo(

		date,
	)
	return body, error
}

// GetPNPMessageStatistics
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get number of sent LINE notification messages
// Parameters:
//        date             Date the message was sent  Format: `yyyyMMdd` (Example:`20211231`) Time zone: UTC+9

// https://developers.line.biz/en/reference/partner-docs/#get-number-of-sent-line-notification-messages
func (client *MessagingApiAPI) GetPNPMessageStatisticsWithHttpInfo(

	date string,

) (*http.Response, *NumberOfMessagesResponse, error) {
	path := "/v2/bot/message/delivery/pnp"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	query.Add("date", date)

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := NumberOfMessagesResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetProfile
//
// Get profile
// Parameters:
//        userId             User ID

// https://developers.line.biz/en/reference/messaging-api/#get-profile
func (client *MessagingApiAPI) GetProfile(

	userId string,

) (*UserProfileResponse, error) {
	_, body, error := client.GetProfileWithHttpInfo(

		userId,
	)
	return body, error
}

// GetProfile
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get profile
// Parameters:
//        userId             User ID

// https://developers.line.biz/en/reference/messaging-api/#get-profile
func (client *MessagingApiAPI) GetProfileWithHttpInfo(

	userId string,

) (*http.Response, *UserProfileResponse, error) {
	path := "/v2/bot/profile/{userId}"

	path = strings.Replace(path, "{userId}", userId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := UserProfileResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetRichMenu
//
// Gets a rich menu via a rich menu ID.
// Parameters:
//        richMenuId             ID of a rich menu

// https://developers.line.biz/en/reference/messaging-api/#get-rich-menu
func (client *MessagingApiAPI) GetRichMenu(

	richMenuId string,

) (*RichMenuResponse, error) {
	_, body, error := client.GetRichMenuWithHttpInfo(

		richMenuId,
	)
	return body, error
}

// GetRichMenu
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Gets a rich menu via a rich menu ID.
// Parameters:
//        richMenuId             ID of a rich menu

// https://developers.line.biz/en/reference/messaging-api/#get-rich-menu
func (client *MessagingApiAPI) GetRichMenuWithHttpInfo(

	richMenuId string,

) (*http.Response, *RichMenuResponse, error) {
	path := "/v2/bot/richmenu/{richMenuId}"

	path = strings.Replace(path, "{richMenuId}", richMenuId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := RichMenuResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetRichMenuAlias
//
// Get rich menu alias information
// Parameters:
//        richMenuAliasId             The rich menu alias ID whose information you want to obtain.

// https://developers.line.biz/en/reference/messaging-api/#get-rich-menu-alias-by-id
func (client *MessagingApiAPI) GetRichMenuAlias(

	richMenuAliasId string,

) (*RichMenuAliasResponse, error) {
	_, body, error := client.GetRichMenuAliasWithHttpInfo(

		richMenuAliasId,
	)
	return body, error
}

// GetRichMenuAlias
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get rich menu alias information
// Parameters:
//        richMenuAliasId             The rich menu alias ID whose information you want to obtain.

// https://developers.line.biz/en/reference/messaging-api/#get-rich-menu-alias-by-id
func (client *MessagingApiAPI) GetRichMenuAliasWithHttpInfo(

	richMenuAliasId string,

) (*http.Response, *RichMenuAliasResponse, error) {
	path := "/v2/bot/richmenu/alias/{richMenuAliasId}"

	path = strings.Replace(path, "{richMenuAliasId}", richMenuAliasId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := RichMenuAliasResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetRichMenuAliasList
//
// Get list of rich menu alias
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-rich-menu-alias-list
func (client *MessagingApiAPI) GetRichMenuAliasList() (*RichMenuAliasListResponse, error) {
	_, body, error := client.GetRichMenuAliasListWithHttpInfo()
	return body, error
}

// GetRichMenuAliasList
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get list of rich menu alias
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-rich-menu-alias-list
func (client *MessagingApiAPI) GetRichMenuAliasListWithHttpInfo() (*http.Response, *RichMenuAliasListResponse, error) {
	path := "/v2/bot/richmenu/alias/list"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := RichMenuAliasListResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetRichMenuBatchProgress
//
// Get the status of Replace or unlink a linked rich menus in batches.
// Parameters:
//        requestId             A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID.

// https://developers.line.biz/en/reference/messaging-api/#get-batch-control-rich-menus-progress-status
func (client *MessagingApiAPI) GetRichMenuBatchProgress(

	requestId string,

) (*RichMenuBatchProgressResponse, error) {
	_, body, error := client.GetRichMenuBatchProgressWithHttpInfo(

		requestId,
	)
	return body, error
}

// GetRichMenuBatchProgress
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get the status of Replace or unlink a linked rich menus in batches.
// Parameters:
//        requestId             A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID.

// https://developers.line.biz/en/reference/messaging-api/#get-batch-control-rich-menus-progress-status
func (client *MessagingApiAPI) GetRichMenuBatchProgressWithHttpInfo(

	requestId string,

) (*http.Response, *RichMenuBatchProgressResponse, error) {
	path := "/v2/bot/richmenu/progress/batch"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	query.Add("requestId", requestId)

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := RichMenuBatchProgressResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetRichMenuIdOfUser
//
// Get rich menu ID of user
// Parameters:
//        userId             User ID. Found in the `source` object of webhook event objects. Do not use the LINE ID used in LINE.

// https://developers.line.biz/en/reference/messaging-api/#get-rich-menu-id-of-user
func (client *MessagingApiAPI) GetRichMenuIdOfUser(

	userId string,

) (*RichMenuIdResponse, error) {
	_, body, error := client.GetRichMenuIdOfUserWithHttpInfo(

		userId,
	)
	return body, error
}

// GetRichMenuIdOfUser
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get rich menu ID of user
// Parameters:
//        userId             User ID. Found in the `source` object of webhook event objects. Do not use the LINE ID used in LINE.

// https://developers.line.biz/en/reference/messaging-api/#get-rich-menu-id-of-user
func (client *MessagingApiAPI) GetRichMenuIdOfUserWithHttpInfo(

	userId string,

) (*http.Response, *RichMenuIdResponse, error) {
	path := "/v2/bot/user/{userId}/richmenu"

	path = strings.Replace(path, "{userId}", userId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := RichMenuIdResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetRichMenuList
//
// Get rich menu list
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-rich-menu-list
func (client *MessagingApiAPI) GetRichMenuList() (*RichMenuListResponse, error) {
	_, body, error := client.GetRichMenuListWithHttpInfo()
	return body, error
}

// GetRichMenuList
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get rich menu list
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-rich-menu-list
func (client *MessagingApiAPI) GetRichMenuListWithHttpInfo() (*http.Response, *RichMenuListResponse, error) {
	path := "/v2/bot/richmenu/list"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := RichMenuListResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetRoomMemberCount
//
// Get number of users in a multi-person chat
// Parameters:
//        roomId             Room ID

// https://developers.line.biz/en/reference/messaging-api/#get-members-room-count
func (client *MessagingApiAPI) GetRoomMemberCount(

	roomId string,

) (*RoomMemberCountResponse, error) {
	_, body, error := client.GetRoomMemberCountWithHttpInfo(

		roomId,
	)
	return body, error
}

// GetRoomMemberCount
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get number of users in a multi-person chat
// Parameters:
//        roomId             Room ID

// https://developers.line.biz/en/reference/messaging-api/#get-members-room-count
func (client *MessagingApiAPI) GetRoomMemberCountWithHttpInfo(

	roomId string,

) (*http.Response, *RoomMemberCountResponse, error) {
	path := "/v2/bot/room/{roomId}/members/count"

	path = strings.Replace(path, "{roomId}", roomId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := RoomMemberCountResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetRoomMemberProfile
//
// Get multi-person chat member profile
// Parameters:
//        roomId             Room ID
//        userId             User ID

// https://developers.line.biz/en/reference/messaging-api/#get-room-member-profile
func (client *MessagingApiAPI) GetRoomMemberProfile(

	roomId string,

	userId string,

) (*RoomUserProfileResponse, error) {
	_, body, error := client.GetRoomMemberProfileWithHttpInfo(

		roomId,

		userId,
	)
	return body, error
}

// GetRoomMemberProfile
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get multi-person chat member profile
// Parameters:
//        roomId             Room ID
//        userId             User ID

// https://developers.line.biz/en/reference/messaging-api/#get-room-member-profile
func (client *MessagingApiAPI) GetRoomMemberProfileWithHttpInfo(

	roomId string,

	userId string,

) (*http.Response, *RoomUserProfileResponse, error) {
	path := "/v2/bot/room/{roomId}/member/{userId}"

	path = strings.Replace(path, "{roomId}", roomId, -1)

	path = strings.Replace(path, "{userId}", userId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := RoomUserProfileResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetRoomMembersIds
//
// Get multi-person chat member user IDs
// Parameters:
//        roomId             Room ID
//        start             Value of the continuation token found in the `next` property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group.

// https://developers.line.biz/en/reference/messaging-api/#get-room-member-user-ids
func (client *MessagingApiAPI) GetRoomMembersIds(

	roomId string,

	start string,

) (*MembersIdsResponse, error) {
	_, body, error := client.GetRoomMembersIdsWithHttpInfo(

		roomId,

		start,
	)
	return body, error
}

// GetRoomMembersIds
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get multi-person chat member user IDs
// Parameters:
//        roomId             Room ID
//        start             Value of the continuation token found in the `next` property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group.

// https://developers.line.biz/en/reference/messaging-api/#get-room-member-user-ids
func (client *MessagingApiAPI) GetRoomMembersIdsWithHttpInfo(

	roomId string,

	start string,

) (*http.Response, *MembersIdsResponse, error) {
	path := "/v2/bot/room/{roomId}/members/ids"

	path = strings.Replace(path, "{roomId}", roomId, -1)

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	query := url.Values{}
	if start != "" {
		query.Add("start", start)
	}

	req.URL.RawQuery = query.Encode()

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := MembersIdsResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// GetWebhookEndpoint
//
// Get webhook endpoint information
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-webhook-endpoint-information
func (client *MessagingApiAPI) GetWebhookEndpoint() (*GetWebhookEndpointResponse, error) {
	_, body, error := client.GetWebhookEndpointWithHttpInfo()
	return body, error
}

// GetWebhookEndpoint
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Get webhook endpoint information
// Parameters:

// https://developers.line.biz/en/reference/messaging-api/#get-webhook-endpoint-information
func (client *MessagingApiAPI) GetWebhookEndpointWithHttpInfo() (*http.Response, *GetWebhookEndpointResponse, error) {
	path := "/v2/bot/channel/webhook/endpoint"

	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GetWebhookEndpointResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// IssueLinkToken
//
// Issue link token
// Parameters:
//        userId             User ID for the LINE account to be linked. Found in the `source` object of account link event objects. Do not use the LINE ID used in LINE.

// https://developers.line.biz/en/reference/messaging-api/#issue-link-token
func (client *MessagingApiAPI) IssueLinkToken(

	userId string,

) (*IssueLinkTokenResponse, error) {
	_, body, error := client.IssueLinkTokenWithHttpInfo(

		userId,
	)
	return body, error
}

// IssueLinkToken
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Issue link token
// Parameters:
//        userId             User ID for the LINE account to be linked. Found in the `source` object of account link event objects. Do not use the LINE ID used in LINE.

// https://developers.line.biz/en/reference/messaging-api/#issue-link-token
func (client *MessagingApiAPI) IssueLinkTokenWithHttpInfo(

	userId string,

) (*http.Response, *IssueLinkTokenResponse, error) {
	path := "/v2/bot/user/{userId}/linkToken"

	path = strings.Replace(path, "{userId}", userId, -1)

	req, err := http.NewRequest(http.MethodPost, client.Url(path), nil)
	if err != nil {
		return nil, nil, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := IssueLinkTokenResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// LeaveGroup
//
// Leave group chat
// Parameters:
//        groupId             Group ID

// https://developers.line.biz/en/reference/messaging-api/#leave-group
func (client *MessagingApiAPI) LeaveGroup(

	groupId string,

) (struct{}, error) {
	_, body, error := client.LeaveGroupWithHttpInfo(

		groupId,
	)
	return body, error
}

// LeaveGroup
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Leave group chat
// Parameters:
//        groupId             Group ID

// https://developers.line.biz/en/reference/messaging-api/#leave-group
func (client *MessagingApiAPI) LeaveGroupWithHttpInfo(

	groupId string,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/group/{groupId}/leave"

	path = strings.Replace(path, "{groupId}", groupId, -1)

	req, err := http.NewRequest(http.MethodPost, client.Url(path), nil)
	if err != nil {
		return nil, struct{}{}, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// LeaveRoom
//
// Leave multi-person chat
// Parameters:
//        roomId             Room ID

// https://developers.line.biz/en/reference/messaging-api/#leave-room
func (client *MessagingApiAPI) LeaveRoom(

	roomId string,

) (struct{}, error) {
	_, body, error := client.LeaveRoomWithHttpInfo(

		roomId,
	)
	return body, error
}

// LeaveRoom
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Leave multi-person chat
// Parameters:
//        roomId             Room ID

// https://developers.line.biz/en/reference/messaging-api/#leave-room
func (client *MessagingApiAPI) LeaveRoomWithHttpInfo(

	roomId string,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/room/{roomId}/leave"

	path = strings.Replace(path, "{roomId}", roomId, -1)

	req, err := http.NewRequest(http.MethodPost, client.Url(path), nil)
	if err != nil {
		return nil, struct{}{}, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// LinkRichMenuIdToUser
//
// Link rich menu to user.
// Parameters:
//        userId             User ID. Found in the `source` object of webhook event objects. Do not use the LINE ID used in LINE.
//        richMenuId             ID of a rich menu

// https://developers.line.biz/en/reference/messaging-api/#link-rich-menu-to-user
func (client *MessagingApiAPI) LinkRichMenuIdToUser(

	userId string,

	richMenuId string,

) (struct{}, error) {
	_, body, error := client.LinkRichMenuIdToUserWithHttpInfo(

		userId,

		richMenuId,
	)
	return body, error
}

// LinkRichMenuIdToUser
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Link rich menu to user.
// Parameters:
//        userId             User ID. Found in the `source` object of webhook event objects. Do not use the LINE ID used in LINE.
//        richMenuId             ID of a rich menu

// https://developers.line.biz/en/reference/messaging-api/#link-rich-menu-to-user
func (client *MessagingApiAPI) LinkRichMenuIdToUserWithHttpInfo(

	userId string,

	richMenuId string,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/user/{userId}/richmenu/{richMenuId}"

	path = strings.Replace(path, "{userId}", userId, -1)

	path = strings.Replace(path, "{richMenuId}", richMenuId, -1)

	req, err := http.NewRequest(http.MethodPost, client.Url(path), nil)
	if err != nil {
		return nil, struct{}{}, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// LinkRichMenuIdToUsers
//
// Link rich menu to multiple users
// Parameters:
//        richMenuBulkLinkRequest

// https://developers.line.biz/en/reference/messaging-api/#link-rich-menu-to-users
func (client *MessagingApiAPI) LinkRichMenuIdToUsers(

	richMenuBulkLinkRequest *RichMenuBulkLinkRequest,

) (struct{}, error) {
	_, body, error := client.LinkRichMenuIdToUsersWithHttpInfo(

		richMenuBulkLinkRequest,
	)
	return body, error
}

// LinkRichMenuIdToUsers
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Link rich menu to multiple users
// Parameters:
//        richMenuBulkLinkRequest

// https://developers.line.biz/en/reference/messaging-api/#link-rich-menu-to-users
func (client *MessagingApiAPI) LinkRichMenuIdToUsersWithHttpInfo(

	richMenuBulkLinkRequest *RichMenuBulkLinkRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/richmenu/bulk/link"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(richMenuBulkLinkRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// MarkMessagesAsRead
//
// Mark messages from users as read
// Parameters:
//        markMessagesAsReadRequest

// https://developers.line.biz/en/reference/partner-docs/#mark-messages-from-users-as-read
func (client *MessagingApiAPI) MarkMessagesAsRead(

	markMessagesAsReadRequest *MarkMessagesAsReadRequest,

) (struct{}, error) {
	_, body, error := client.MarkMessagesAsReadWithHttpInfo(

		markMessagesAsReadRequest,
	)
	return body, error
}

// MarkMessagesAsRead
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Mark messages from users as read
// Parameters:
//        markMessagesAsReadRequest

// https://developers.line.biz/en/reference/partner-docs/#mark-messages-from-users-as-read
func (client *MessagingApiAPI) MarkMessagesAsReadWithHttpInfo(

	markMessagesAsReadRequest *MarkMessagesAsReadRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/message/markAsRead"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(markMessagesAsReadRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// Multicast
//
// An API that efficiently sends the same message to multiple user IDs. You can't send messages to group chats or multi-person chats.
// Parameters:
//        multicastRequest
//        xLineRetryKey             Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.

// https://developers.line.biz/en/reference/messaging-api/#send-multicast-message
func (client *MessagingApiAPI) Multicast(

	multicastRequest *MulticastRequest,

	xLineRetryKey string,

) (*map[string]interface{}, error) {
	_, body, error := client.MulticastWithHttpInfo(

		multicastRequest,

		xLineRetryKey,
	)
	return body, error
}

// Multicast
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// An API that efficiently sends the same message to multiple user IDs. You can't send messages to group chats or multi-person chats.
// Parameters:
//        multicastRequest
//        xLineRetryKey             Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.

// https://developers.line.biz/en/reference/messaging-api/#send-multicast-message
func (client *MessagingApiAPI) MulticastWithHttpInfo(

	multicastRequest *MulticastRequest,

	xLineRetryKey string,

) (*http.Response, *map[string]interface{}, error) {
	path := "/v2/bot/message/multicast"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(multicastRequest); err != nil {
		return nil, nil, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	req.Header.Set("X-Line-Retry-Key", xLineRetryKey)

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := map[string]interface{}{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// Narrowcast
//
// Send narrowcast message
// Parameters:
//        narrowcastRequest
//        xLineRetryKey             Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.

// https://developers.line.biz/en/reference/messaging-api/#send-narrowcast-message
func (client *MessagingApiAPI) Narrowcast(

	narrowcastRequest *NarrowcastRequest,

	xLineRetryKey string,

) (*map[string]interface{}, error) {
	_, body, error := client.NarrowcastWithHttpInfo(

		narrowcastRequest,

		xLineRetryKey,
	)
	return body, error
}

// Narrowcast
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Send narrowcast message
// Parameters:
//        narrowcastRequest
//        xLineRetryKey             Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.

// https://developers.line.biz/en/reference/messaging-api/#send-narrowcast-message
func (client *MessagingApiAPI) NarrowcastWithHttpInfo(

	narrowcastRequest *NarrowcastRequest,

	xLineRetryKey string,

) (*http.Response, *map[string]interface{}, error) {
	path := "/v2/bot/message/narrowcast"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(narrowcastRequest); err != nil {
		return nil, nil, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	req.Header.Set("X-Line-Retry-Key", xLineRetryKey)

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := map[string]interface{}{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// PushMessage
//
// Sends a message to a user, group chat, or multi-person chat at any time.
// Parameters:
//        pushMessageRequest
//        xLineRetryKey             Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.

// https://developers.line.biz/en/reference/messaging-api/#send-push-message
func (client *MessagingApiAPI) PushMessage(

	pushMessageRequest *PushMessageRequest,

	xLineRetryKey string,

) (*PushMessageResponse, error) {
	_, body, error := client.PushMessageWithHttpInfo(

		pushMessageRequest,

		xLineRetryKey,
	)
	return body, error
}

// PushMessage
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Sends a message to a user, group chat, or multi-person chat at any time.
// Parameters:
//        pushMessageRequest
//        xLineRetryKey             Retry key. Specifies the UUID in hexadecimal format (e.g., `123e4567-e89b-12d3-a456-426614174000`) generated by any method. The retry key isn't generated by LINE. Each developer must generate their own retry key.

// https://developers.line.biz/en/reference/messaging-api/#send-push-message
func (client *MessagingApiAPI) PushMessageWithHttpInfo(

	pushMessageRequest *PushMessageRequest,

	xLineRetryKey string,

) (*http.Response, *PushMessageResponse, error) {
	path := "/v2/bot/message/push"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(pushMessageRequest); err != nil {
		return nil, nil, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	req.Header.Set("X-Line-Retry-Key", xLineRetryKey)

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := PushMessageResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// PushMessagesByPhone
//
// Send LINE notification message
// Parameters:
//        pnpMessagesRequest
//        xLineDeliveryTag             String returned in the delivery.data property of the delivery completion event via Webhook.

// https://developers.line.biz/en/reference/partner-docs/#send-line-notification-message
func (client *MessagingApiAPI) PushMessagesByPhone(

	pnpMessagesRequest *PnpMessagesRequest,

	xLineDeliveryTag string,

) (struct{}, error) {
	_, body, error := client.PushMessagesByPhoneWithHttpInfo(

		pnpMessagesRequest,

		xLineDeliveryTag,
	)
	return body, error
}

// PushMessagesByPhone
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Send LINE notification message
// Parameters:
//        pnpMessagesRequest
//        xLineDeliveryTag             String returned in the delivery.data property of the delivery completion event via Webhook.

// https://developers.line.biz/en/reference/partner-docs/#send-line-notification-message
func (client *MessagingApiAPI) PushMessagesByPhoneWithHttpInfo(

	pnpMessagesRequest *PnpMessagesRequest,

	xLineDeliveryTag string,

) (*http.Response, struct{}, error) {
	path := "/bot/pnp/push"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(pnpMessagesRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	req.Header.Set("X-Line-Delivery-Tag", xLineDeliveryTag)

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// ReplyMessage
//
// Send reply message
// Parameters:
//        replyMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#send-reply-message
func (client *MessagingApiAPI) ReplyMessage(

	replyMessageRequest *ReplyMessageRequest,

) (*ReplyMessageResponse, error) {
	_, body, error := client.ReplyMessageWithHttpInfo(

		replyMessageRequest,
	)
	return body, error
}

// ReplyMessage
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Send reply message
// Parameters:
//        replyMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#send-reply-message
func (client *MessagingApiAPI) ReplyMessageWithHttpInfo(

	replyMessageRequest *ReplyMessageRequest,

) (*http.Response, *ReplyMessageResponse, error) {
	path := "/v2/bot/message/reply"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(replyMessageRequest); err != nil {
		return nil, nil, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := ReplyMessageResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// RichMenuBatch
//
// You can use this endpoint to batch control the rich menu linked to the users using the endpoint such as Link rich menu to user. The following operations are available:  1. Replace a rich menu with another rich menu for all users linked to a specific rich menu 2. Unlink a rich menu for all users linked to a specific rich menu 3. Unlink a rich menu for all users linked the rich menu
// Parameters:
//        richMenuBatchRequest

// https://developers.line.biz/en/reference/messaging-api/#batch-control-rich-menus-of-users
func (client *MessagingApiAPI) RichMenuBatch(

	richMenuBatchRequest *RichMenuBatchRequest,

) (struct{}, error) {
	_, body, error := client.RichMenuBatchWithHttpInfo(

		richMenuBatchRequest,
	)
	return body, error
}

// RichMenuBatch
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// You can use this endpoint to batch control the rich menu linked to the users using the endpoint such as Link rich menu to user. The following operations are available:  1. Replace a rich menu with another rich menu for all users linked to a specific rich menu 2. Unlink a rich menu for all users linked to a specific rich menu 3. Unlink a rich menu for all users linked the rich menu
// Parameters:
//        richMenuBatchRequest

// https://developers.line.biz/en/reference/messaging-api/#batch-control-rich-menus-of-users
func (client *MessagingApiAPI) RichMenuBatchWithHttpInfo(

	richMenuBatchRequest *RichMenuBatchRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/richmenu/batch"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(richMenuBatchRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// SetDefaultRichMenu
//
// Set default rich menu
// Parameters:
//        richMenuId             ID of a rich menu

// https://developers.line.biz/en/reference/messaging-api/#set-default-rich-menu
func (client *MessagingApiAPI) SetDefaultRichMenu(

	richMenuId string,

) (struct{}, error) {
	_, body, error := client.SetDefaultRichMenuWithHttpInfo(

		richMenuId,
	)
	return body, error
}

// SetDefaultRichMenu
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Set default rich menu
// Parameters:
//        richMenuId             ID of a rich menu

// https://developers.line.biz/en/reference/messaging-api/#set-default-rich-menu
func (client *MessagingApiAPI) SetDefaultRichMenuWithHttpInfo(

	richMenuId string,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/user/all/richmenu/{richMenuId}"

	path = strings.Replace(path, "{richMenuId}", richMenuId, -1)

	req, err := http.NewRequest(http.MethodPost, client.Url(path), nil)
	if err != nil {
		return nil, struct{}{}, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// SetWebhookEndpoint
//
// Set webhook endpoint URL
// Parameters:
//        setWebhookEndpointRequest

// https://developers.line.biz/en/reference/messaging-api/#set-webhook-endpoint-url
func (client *MessagingApiAPI) SetWebhookEndpoint(

	setWebhookEndpointRequest *SetWebhookEndpointRequest,

) (struct{}, error) {
	_, body, error := client.SetWebhookEndpointWithHttpInfo(

		setWebhookEndpointRequest,
	)
	return body, error
}

// SetWebhookEndpoint
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Set webhook endpoint URL
// Parameters:
//        setWebhookEndpointRequest

// https://developers.line.biz/en/reference/messaging-api/#set-webhook-endpoint-url
func (client *MessagingApiAPI) SetWebhookEndpointWithHttpInfo(

	setWebhookEndpointRequest *SetWebhookEndpointRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/channel/webhook/endpoint"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(setWebhookEndpointRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPut, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// ShowLoadingAnimation
//
// Display a loading animation in one-on-one chats between users and LINE Official Accounts.
// Parameters:
//        showLoadingAnimationRequest

// https://developers.line.biz/en/reference/messaging-api/#display-a-loading-indicator
func (client *MessagingApiAPI) ShowLoadingAnimation(

	showLoadingAnimationRequest *ShowLoadingAnimationRequest,

) (*map[string]interface{}, error) {
	_, body, error := client.ShowLoadingAnimationWithHttpInfo(

		showLoadingAnimationRequest,
	)
	return body, error
}

// ShowLoadingAnimation
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Display a loading animation in one-on-one chats between users and LINE Official Accounts.
// Parameters:
//        showLoadingAnimationRequest

// https://developers.line.biz/en/reference/messaging-api/#display-a-loading-indicator
func (client *MessagingApiAPI) ShowLoadingAnimationWithHttpInfo(

	showLoadingAnimationRequest *ShowLoadingAnimationRequest,

) (*http.Response, *map[string]interface{}, error) {
	path := "/v2/bot/chat/loading/start"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(showLoadingAnimationRequest); err != nil {
		return nil, nil, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := map[string]interface{}{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// TestWebhookEndpoint
//
// Test webhook endpoint
// Parameters:
//        testWebhookEndpointRequest

// https://developers.line.biz/en/reference/messaging-api/#test-webhook-endpoint
func (client *MessagingApiAPI) TestWebhookEndpoint(

	testWebhookEndpointRequest *TestWebhookEndpointRequest,

) (*TestWebhookEndpointResponse, error) {
	_, body, error := client.TestWebhookEndpointWithHttpInfo(

		testWebhookEndpointRequest,
	)
	return body, error
}

// TestWebhookEndpoint
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Test webhook endpoint
// Parameters:
//        testWebhookEndpointRequest

// https://developers.line.biz/en/reference/messaging-api/#test-webhook-endpoint
func (client *MessagingApiAPI) TestWebhookEndpointWithHttpInfo(

	testWebhookEndpointRequest *TestWebhookEndpointRequest,

) (*http.Response, *TestWebhookEndpointResponse, error) {
	path := "/v2/bot/channel/webhook/test"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(testWebhookEndpointRequest); err != nil {
		return nil, nil, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, nil, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, nil, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := TestWebhookEndpointResponse{}
	if err := decoder.Decode(&result); err != nil {
		return res, nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return res, &result, nil

}

// UnlinkRichMenuIdFromUser
//
// Unlink rich menu from user
// Parameters:
//        userId             User ID. Found in the `source` object of webhook event objects. Do not use the LINE ID used in LINE.

// https://developers.line.biz/en/reference/messaging-api/#unlink-rich-menu-from-user
func (client *MessagingApiAPI) UnlinkRichMenuIdFromUser(

	userId string,

) (struct{}, error) {
	_, body, error := client.UnlinkRichMenuIdFromUserWithHttpInfo(

		userId,
	)
	return body, error
}

// UnlinkRichMenuIdFromUser
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Unlink rich menu from user
// Parameters:
//        userId             User ID. Found in the `source` object of webhook event objects. Do not use the LINE ID used in LINE.

// https://developers.line.biz/en/reference/messaging-api/#unlink-rich-menu-from-user
func (client *MessagingApiAPI) UnlinkRichMenuIdFromUserWithHttpInfo(

	userId string,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/user/{userId}/richmenu"

	path = strings.Replace(path, "{userId}", userId, -1)

	req, err := http.NewRequest(http.MethodDelete, client.Url(path), nil)
	if err != nil {
		return nil, struct{}{}, err
	}

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// UnlinkRichMenuIdFromUsers
//
// Unlink rich menus from multiple users
// Parameters:
//        richMenuBulkUnlinkRequest

// https://developers.line.biz/en/reference/messaging-api/#unlink-rich-menu-from-users
func (client *MessagingApiAPI) UnlinkRichMenuIdFromUsers(

	richMenuBulkUnlinkRequest *RichMenuBulkUnlinkRequest,

) (struct{}, error) {
	_, body, error := client.UnlinkRichMenuIdFromUsersWithHttpInfo(

		richMenuBulkUnlinkRequest,
	)
	return body, error
}

// UnlinkRichMenuIdFromUsers
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Unlink rich menus from multiple users
// Parameters:
//        richMenuBulkUnlinkRequest

// https://developers.line.biz/en/reference/messaging-api/#unlink-rich-menu-from-users
func (client *MessagingApiAPI) UnlinkRichMenuIdFromUsersWithHttpInfo(

	richMenuBulkUnlinkRequest *RichMenuBulkUnlinkRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/richmenu/bulk/unlink"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(richMenuBulkUnlinkRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// UpdateRichMenuAlias
//
// Update rich menu alias
// Parameters:
//        richMenuAliasId             The rich menu alias ID you want to update.
//        updateRichMenuAliasRequest

// https://developers.line.biz/en/reference/messaging-api/#update-rich-menu-alias
func (client *MessagingApiAPI) UpdateRichMenuAlias(

	richMenuAliasId string,

	updateRichMenuAliasRequest *UpdateRichMenuAliasRequest,

) (struct{}, error) {
	_, body, error := client.UpdateRichMenuAliasWithHttpInfo(

		richMenuAliasId,

		updateRichMenuAliasRequest,
	)
	return body, error
}

// UpdateRichMenuAlias
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Update rich menu alias
// Parameters:
//        richMenuAliasId             The rich menu alias ID you want to update.
//        updateRichMenuAliasRequest

// https://developers.line.biz/en/reference/messaging-api/#update-rich-menu-alias
func (client *MessagingApiAPI) UpdateRichMenuAliasWithHttpInfo(

	richMenuAliasId string,

	updateRichMenuAliasRequest *UpdateRichMenuAliasRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/richmenu/alias/{richMenuAliasId}"

	path = strings.Replace(path, "{richMenuAliasId}", richMenuAliasId, -1)

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(updateRichMenuAliasRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// ValidateBroadcast
//
// Validate message objects of a broadcast message
// Parameters:
//        validateMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-message-objects-of-broadcast-message
func (client *MessagingApiAPI) ValidateBroadcast(

	validateMessageRequest *ValidateMessageRequest,

) (struct{}, error) {
	_, body, error := client.ValidateBroadcastWithHttpInfo(

		validateMessageRequest,
	)
	return body, error
}

// ValidateBroadcast
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Validate message objects of a broadcast message
// Parameters:
//        validateMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-message-objects-of-broadcast-message
func (client *MessagingApiAPI) ValidateBroadcastWithHttpInfo(

	validateMessageRequest *ValidateMessageRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/message/validate/broadcast"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(validateMessageRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// ValidateMulticast
//
// Validate message objects of a multicast message
// Parameters:
//        validateMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-message-objects-of-multicast-message
func (client *MessagingApiAPI) ValidateMulticast(

	validateMessageRequest *ValidateMessageRequest,

) (struct{}, error) {
	_, body, error := client.ValidateMulticastWithHttpInfo(

		validateMessageRequest,
	)
	return body, error
}

// ValidateMulticast
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Validate message objects of a multicast message
// Parameters:
//        validateMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-message-objects-of-multicast-message
func (client *MessagingApiAPI) ValidateMulticastWithHttpInfo(

	validateMessageRequest *ValidateMessageRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/message/validate/multicast"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(validateMessageRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// ValidateNarrowcast
//
// Validate message objects of a narrowcast message
// Parameters:
//        validateMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-message-objects-of-narrowcast-message
func (client *MessagingApiAPI) ValidateNarrowcast(

	validateMessageRequest *ValidateMessageRequest,

) (struct{}, error) {
	_, body, error := client.ValidateNarrowcastWithHttpInfo(

		validateMessageRequest,
	)
	return body, error
}

// ValidateNarrowcast
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Validate message objects of a narrowcast message
// Parameters:
//        validateMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-message-objects-of-narrowcast-message
func (client *MessagingApiAPI) ValidateNarrowcastWithHttpInfo(

	validateMessageRequest *ValidateMessageRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/message/validate/narrowcast"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(validateMessageRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// ValidatePush
//
// Validate message objects of a push message
// Parameters:
//        validateMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-message-objects-of-push-message
func (client *MessagingApiAPI) ValidatePush(

	validateMessageRequest *ValidateMessageRequest,

) (struct{}, error) {
	_, body, error := client.ValidatePushWithHttpInfo(

		validateMessageRequest,
	)
	return body, error
}

// ValidatePush
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Validate message objects of a push message
// Parameters:
//        validateMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-message-objects-of-push-message
func (client *MessagingApiAPI) ValidatePushWithHttpInfo(

	validateMessageRequest *ValidateMessageRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/message/validate/push"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(validateMessageRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// ValidateReply
//
// Validate message objects of a reply message
// Parameters:
//        validateMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-message-objects-of-reply-message
func (client *MessagingApiAPI) ValidateReply(

	validateMessageRequest *ValidateMessageRequest,

) (struct{}, error) {
	_, body, error := client.ValidateReplyWithHttpInfo(

		validateMessageRequest,
	)
	return body, error
}

// ValidateReply
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Validate message objects of a reply message
// Parameters:
//        validateMessageRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-message-objects-of-reply-message
func (client *MessagingApiAPI) ValidateReplyWithHttpInfo(

	validateMessageRequest *ValidateMessageRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/message/validate/reply"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(validateMessageRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// ValidateRichMenuBatchRequest
//
// Validate a request body of the Replace or unlink the linked rich menus in batches endpoint.
// Parameters:
//        richMenuBatchRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-batch-control-rich-menus-request
func (client *MessagingApiAPI) ValidateRichMenuBatchRequest(

	richMenuBatchRequest *RichMenuBatchRequest,

) (struct{}, error) {
	_, body, error := client.ValidateRichMenuBatchRequestWithHttpInfo(

		richMenuBatchRequest,
	)
	return body, error
}

// ValidateRichMenuBatchRequest
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Validate a request body of the Replace or unlink the linked rich menus in batches endpoint.
// Parameters:
//        richMenuBatchRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-batch-control-rich-menus-request
func (client *MessagingApiAPI) ValidateRichMenuBatchRequestWithHttpInfo(

	richMenuBatchRequest *RichMenuBatchRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/richmenu/validate/batch"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(richMenuBatchRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}

// ValidateRichMenuObject
//
// Validate rich menu object
// Parameters:
//        richMenuRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-rich-menu-object
func (client *MessagingApiAPI) ValidateRichMenuObject(

	richMenuRequest *RichMenuRequest,

) (struct{}, error) {
	_, body, error := client.ValidateRichMenuObjectWithHttpInfo(

		richMenuRequest,
	)
	return body, error
}

// ValidateRichMenuObject
// If you want to take advantage of the HTTPResponse object for status codes and headers, use this signature.
//
// Validate rich menu object
// Parameters:
//        richMenuRequest

// https://developers.line.biz/en/reference/messaging-api/#validate-rich-menu-object
func (client *MessagingApiAPI) ValidateRichMenuObjectWithHttpInfo(

	richMenuRequest *RichMenuRequest,

) (*http.Response, struct{}, error) {
	path := "/v2/bot/richmenu/validate"

	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	if err := enc.Encode(richMenuRequest); err != nil {
		return nil, struct{}{}, err
	}
	req, err := http.NewRequest(http.MethodPost, client.Url(path), &buf)
	if err != nil {
		return nil, struct{}{}, err
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")

	res, err := client.Do(req)

	if err != nil {
		return res, struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		bodyBytes, err := io.ReadAll(res.Body)
		bodyReader := bytes.NewReader(bodyBytes)
		if err != nil {
			return res, struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		res.Body = io.NopCloser(bodyReader)
		return res, struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(bodyBytes))
	}

	defer res.Body.Close()

	return res, struct{}{}, nil

}
