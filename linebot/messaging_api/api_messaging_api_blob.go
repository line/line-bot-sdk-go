/**
 * LINE Messaging API
 * This document describes LINE Messaging API.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

//go:generate python3 ../../generate-code.py

package messaging_api

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/line/line-bot-sdk-go/v7/linebot"
)

type MessagingApiBlobAPI struct {
	httpClient   *http.Client
	endpoint     *url.URL
	channelToken string
	ctx          context.Context
}

// MessagingApiBlobAPIOption type
type MessagingApiBlobAPIOption func(*MessagingApiBlobAPI) error

// New returns a new bot client instance.
func NewMessagingApiBlobAPI(channelToken string, options ...MessagingApiBlobAPIOption) (*MessagingApiBlobAPI, error) {
	if channelToken == "" {
		return nil, errors.New("missing channel access token")
	}

	c := &MessagingApiBlobAPI{
		channelToken: channelToken,
		httpClient:   http.DefaultClient,
	}
	err := c.SetEndpoint("https://api-data.line.me")
	if err != nil {
		return nil, err
	}
	for _, option := range options {
		err := option(c)
		if err != nil {
			return nil, err
		}
	}
	return c, nil
}

// WithContext method
func (call *MessagingApiBlobAPI) WithContext(ctx context.Context) *MessagingApiBlobAPI {
	call.ctx = ctx
	return call
}

func (client *MessagingApiBlobAPI) Do(req *http.Request) (*http.Response, error) {
	if client.channelToken != "" {
		req.Header.Set("Authorization", "Bearer "+client.channelToken)
	}
	req.Header.Set("User-Agent", "LINE-BotSDK-Go/"+linebot.GetVersion())
	if client.ctx != nil {
		req = req.WithContext(client.ctx)
	}
	return client.httpClient.Do(req)
}

func (client *MessagingApiBlobAPI) Url(endpointPath string) string {
	u := client.endpoint
	u.Path = path.Join(u.Path, endpointPath)
	return u.String()
}

func (client *MessagingApiBlobAPI) SetEndpoint(endpoint string) error {
	u, err := url.ParseRequestURI(endpoint)
	if err != nil {
		return err
	}
	client.endpoint = u
	return nil
}

// GetMessageContent
//
// Download image, video, and audio data sent from users.
// Parameters:
//        messageId             Message ID of video or audio

// You must close the response body when finished with it.
// https://developers.line.biz/en/reference/messaging-api/#get-content
func (client *MessagingApiBlobAPI) GetMessageContent(

	messageId string,

) (*http.Response, error) {
	path := "/v2/bot/message/{messageId}/content"

	path = strings.Replace(path, "{messageId}", messageId, -1)

	log.Printf("Sending request: method=Get path=%s\n", path)
	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, err
	}

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return nil, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		return nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	return res, nil

}

// GetMessageContentPreview
//
// Get a preview image of the image or video
// Parameters:
//        messageId             Message ID of image or video

// You must close the response body when finished with it.
// https://developers.line.biz/en/reference/messaging-api/#get-image-or-video-preview
func (client *MessagingApiBlobAPI) GetMessageContentPreview(

	messageId string,

) (*http.Response, error) {
	path := "/v2/bot/message/{messageId}/content/preview"

	path = strings.Replace(path, "{messageId}", messageId, -1)

	log.Printf("Sending request: method=Get path=%s\n", path)
	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, err
	}

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return nil, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		return nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	return res, nil

}

// GetMessageContentTranscodingByMessageId
//
// Verify the preparation status of a video or audio for getting
// Parameters:
//        messageId             Message ID of video or audio

// https://developers.line.biz/en/reference/messaging-api/#verify-video-or-audio-preparation-status
func (client *MessagingApiBlobAPI) GetMessageContentTranscodingByMessageId(

	messageId string,

) (*GetMessageContentTranscodingResponse, error) {
	path := "/v2/bot/message/{messageId}/content/transcoding"

	path = strings.Replace(path, "{messageId}", messageId, -1)

	log.Printf("Sending request: method=Get path=%s\n", path)
	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, err
	}

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return nil, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		return nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	defer res.Body.Close()

	decoder := json.NewDecoder(res.Body)
	result := GetMessageContentTranscodingResponse{}
	if err := decoder.Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return &result, nil

}

// GetRichMenuImage
//
// Download rich menu image.
// Parameters:
//        richMenuId             ID of the rich menu with the image to be downloaded

// You must close the response body when finished with it.
// https://developers.line.biz/en/reference/messaging-api/#download-rich-menu-image
func (client *MessagingApiBlobAPI) GetRichMenuImage(

	richMenuId string,

) (*http.Response, error) {
	path := "/v2/bot/richmenu/{richMenuId}/content"

	path = strings.Replace(path, "{richMenuId}", richMenuId, -1)

	log.Printf("Sending request: method=Get path=%s\n", path)
	req, err := http.NewRequest(http.MethodGet, client.Url(path), nil)
	if err != nil {
		return nil, err
	}

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return nil, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		return nil, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	return res, nil

}

// SetRichMenuImage
//
// Upload rich menu image
// Parameters:
//        richMenuId             The ID of the rich menu to attach the image to
//        bodyContentType   content-type
//        bodyReader        file content

// https://developers.line.biz/en/reference/messaging-api/#upload-rich-menu-image
func (client *MessagingApiBlobAPI) SetRichMenuImage(

	richMenuId string,

	bodyContentType string,
	bodyReader io.Reader,

) (struct{}, error) {
	path := "/v2/bot/richmenu/{richMenuId}/content"

	path = strings.Replace(path, "{richMenuId}", richMenuId, -1)

	log.Printf("Sending request: method=Post path=%s bodyContentType=%s\n", path, bodyContentType)
	req, err := http.NewRequest(http.MethodPost, client.Url(path), bodyReader)
	if err != nil {
		return struct{}{}, err
	}
	req.Header.Set("Content-Type", bodyContentType)

	res, err := client.Do(req)
	log.Printf("Got response from '%s %s': status=%d, contentLength=%d", req.Method, req.URL, res.StatusCode, res.ContentLength)

	if err != nil {
		return struct{}{}, err
	}

	if res.StatusCode/100 != 2 {
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return struct{}{}, fmt.Errorf("failed to read response body: %w", err)
		}
		return struct{}{}, fmt.Errorf("unexpected status code: %d, %s", res.StatusCode, string(body))
	}

	defer res.Body.Close()

	return struct{}{}, nil

}
