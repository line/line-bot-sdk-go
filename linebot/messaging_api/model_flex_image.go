/**
 * LINE Messaging API
 * This document describes LINE Messaging API.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

//go:generate python3 ../../generate-code.py
package messaging_api

import (
	"encoding/json"
	"fmt"
)

// FlexImage
// FlexImage
// https://developers.line.biz/en/reference/messaging-api/#f-image
type FlexImage struct {
	FlexComponent

	/**
	 * Image URL (Max character limit: 2000) Protocol: HTTPS (TLS 1.2 or later) Image format: JPEG or PNG Maximum image size: 1024Ã—1024 pixels Maximum file size: 10 MB (300 KB when the animated property is true)  (Required)
	 */
	Url string `json:"url"`

	/**
	 * The ratio of the width or height of this component within the parent box.
	 */
	Flex int32 `json:"flex"`

	/**
	 * The minimum amount of space to include before this component in its parent container.
	 */
	Margin string `json:"margin,omitempty"`

	/**
	 * Reference for offsetTop, offsetBottom, offsetStart, and offsetEnd. Specify one of the following values:  `relative`: Use the previous box as reference. `absolute`: Use the top left of parent element as reference. The default value is relative.
	 */
	Position FlexImagePOSITION `json:"position,omitempty"`

	/**
	 * Offset.
	 */
	OffsetTop string `json:"offsetTop,omitempty"`

	/**
	 * Offset.
	 */
	OffsetBottom string `json:"offsetBottom,omitempty"`

	/**
	 * Offset.
	 */
	OffsetStart string `json:"offsetStart,omitempty"`

	/**
	 * Offset.
	 */
	OffsetEnd string `json:"offsetEnd,omitempty"`

	/**
	 * Alignment style in horizontal direction.
	 */
	Align FlexImageALIGN `json:"align,omitempty"`

	/**
	 * Alignment style in vertical direction.
	 */
	Gravity FlexImageGRAVITY `json:"gravity,omitempty"`

	/**
	 * The maximum image width. This is md by default.
	 */
	Size string `json:"size,omitempty"`

	/**
	 * Aspect ratio of the image. `{width}:{height}` format. Specify the value of `{width}` and `{height}` in the range from `1` to `100000`. However, you cannot set `{height}` to a value that is more than three times the value of `{width}`. The default value is `1:1`.
	 */
	AspectRatio string `json:"aspectRatio,omitempty"`

	/**
	 * The display style of the image if the aspect ratio of the image and that specified by the aspectRatio property do not match.
	 */
	AspectMode FlexImageASPECT_MODE `json:"aspectMode,omitempty"`

	/**
	 * Background color of the image. Use a hexadecimal color code.
	 */
	BackgroundColor string `json:"backgroundColor,omitempty"`

	/**
	 * Get Action
	 */
	Action ActionInterface `json:"action,omitempty"`

	/**
	 * When this is `true`, an animated image (APNG) plays. You can specify a value of true up to 10 images in a single message. You can&#39;t send messages that exceed this limit. This is `false` by default. Animated images larger than 300 KB aren&#39;t played back.
	 */
	Animated bool `json:"animated"`
}

func (cr *FlexImage) UnmarshalJSON(data []byte) error {
	var raw map[string]json.RawMessage
	err := json.Unmarshal(data, &raw)
	if err != nil {
		return fmt.Errorf("JSON parse error in map: %w", err)
	}

	if raw["type"] != nil {

		err = json.Unmarshal(raw["type"], &cr.Type)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Type): %w", err)
		}

	}

	if raw["url"] != nil {

		err = json.Unmarshal(raw["url"], &cr.Url)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Url): %w", err)
		}

	}

	if raw["flex"] != nil {

		err = json.Unmarshal(raw["flex"], &cr.Flex)
		if err != nil {
			return fmt.Errorf("JSON parse error in int32(Flex): %w", err)
		}

	}

	if raw["margin"] != nil {

		err = json.Unmarshal(raw["margin"], &cr.Margin)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Margin): %w", err)
		}

	}

	if raw["position"] != nil {

		err = json.Unmarshal(raw["position"], &cr.Position)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Position): %w", err)
		}

	}

	if raw["offsetTop"] != nil {

		err = json.Unmarshal(raw["offsetTop"], &cr.OffsetTop)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(OffsetTop): %w", err)
		}

	}

	if raw["offsetBottom"] != nil {

		err = json.Unmarshal(raw["offsetBottom"], &cr.OffsetBottom)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(OffsetBottom): %w", err)
		}

	}

	if raw["offsetStart"] != nil {

		err = json.Unmarshal(raw["offsetStart"], &cr.OffsetStart)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(OffsetStart): %w", err)
		}

	}

	if raw["offsetEnd"] != nil {

		err = json.Unmarshal(raw["offsetEnd"], &cr.OffsetEnd)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(OffsetEnd): %w", err)
		}

	}

	if raw["align"] != nil {

		err = json.Unmarshal(raw["align"], &cr.Align)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Align): %w", err)
		}

	}

	if raw["gravity"] != nil {

		err = json.Unmarshal(raw["gravity"], &cr.Gravity)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Gravity): %w", err)
		}

	}

	if raw["size"] != nil {

		err = json.Unmarshal(raw["size"], &cr.Size)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(Size): %w", err)
		}

	}

	if raw["aspectRatio"] != nil {

		err = json.Unmarshal(raw["aspectRatio"], &cr.AspectRatio)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(AspectRatio): %w", err)
		}

	}

	if raw["aspectMode"] != nil {

		err = json.Unmarshal(raw["aspectMode"], &cr.AspectMode)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(AspectMode): %w", err)
		}

	}

	if raw["backgroundColor"] != nil {

		err = json.Unmarshal(raw["backgroundColor"], &cr.BackgroundColor)
		if err != nil {
			return fmt.Errorf("JSON parse error in string(BackgroundColor): %w", err)
		}

	}

	if raw["action"] != nil {

		if rawaction, ok := raw["action"]; ok && rawaction != nil {
			Action, err := UnmarshalAction(rawaction)
			if err != nil {
				return fmt.Errorf("JSON parse error in Action(discriminator): %w", err)
			}
			cr.Action = Action
		}

	}

	if raw["animated"] != nil {

		err = json.Unmarshal(raw["animated"], &cr.Animated)
		if err != nil {
			return fmt.Errorf("JSON parse error in bool(Animated): %w", err)
		}

	}

	return nil
}

// MarshalJSON customizes the JSON serialization of the FlexImage struct.
func (r *FlexImage) MarshalJSON() ([]byte, error) {

	r.Action = setDiscriminatorPropertyAction(r.Action)

	type Alias FlexImage
	return json.Marshal(&struct {
		*Alias

		Type string `json:"type"`
	}{
		Alias: (*Alias)(r),

		Type: "image",
	})
}

// FlexImagePOSITION type
/* Reference for offsetTop, offsetBottom, offsetStart, and offsetEnd. Specify one of the following values:  `relative`: Use the previous box as reference. `absolute`: Use the top left of parent element as reference. The default value is relative.  */
type FlexImagePOSITION string

// FlexImagePOSITION constants
const (
	FlexImagePOSITION_RELATIVE FlexImagePOSITION = "relative"

	FlexImagePOSITION_ABSOLUTE FlexImagePOSITION = "absolute"
)

// FlexImageALIGN type
/* Alignment style in horizontal direction.  */
type FlexImageALIGN string

// FlexImageALIGN constants
const (
	FlexImageALIGN_START FlexImageALIGN = "start"

	FlexImageALIGN_END FlexImageALIGN = "end"

	FlexImageALIGN_CENTER FlexImageALIGN = "center"
)

// FlexImageGRAVITY type
/* Alignment style in vertical direction. */
type FlexImageGRAVITY string

// FlexImageGRAVITY constants
const (
	FlexImageGRAVITY_TOP FlexImageGRAVITY = "top"

	FlexImageGRAVITY_BOTTOM FlexImageGRAVITY = "bottom"

	FlexImageGRAVITY_CENTER FlexImageGRAVITY = "center"
)

// FlexImageASPECT_MODE type
/* The display style of the image if the aspect ratio of the image and that specified by the aspectRatio property do not match.  */
type FlexImageASPECT_MODE string

// FlexImageASPECT_MODE constants
const (
	FlexImageASPECT_MODE_FIT FlexImageASPECT_MODE = "fit"

	FlexImageASPECT_MODE_COVER FlexImageASPECT_MODE = "cover"
)
